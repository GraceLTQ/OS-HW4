Issue: Safety violation

Modules:
  alloc: /Users/liutianqing/.local/lib/python3.8/site-packages/harmony_model_checker/modules/alloc.hny
  bag: /Users/liutianqing/.local/lib/python3.8/site-packages/harmony_model_checker/modules/bag.hny
  __main__: /Users/liutianqing/Desktop/OS-HW4/deque_test.hny
  synch: /Users/liutianqing/.local/lib/python3.8/site-packages/harmony_model_checker/modules/synch.hny
  deque: /Users/liutianqing/Desktop/OS-HW4/deque_impl.hny
  list: /Users/liutianqing/.local/lib/python3.8/site-packages/harmony_model_checker/modules/list.hny

================================================
Running thread T0: __init__()
mode:  runnable atomic
stack: ['[]']
state id: 1
================================================

Step 1:
  program counter:   0
  hvm code:          Frame __init__()
  explanation:       pop argument () and run method "__init__"
  module:            __main__
  start statement:   line=25 column=1
  end statement:     line=67 column=6
  source code:       import deque
  call trace:        __init__()
  stack:             [{:}]

Step 2:
  program counter:   1
  hvm code:          Jump 54
  explanation:       jump over method definition: set program counter to 54
  module:            list
  start statement:   line=2 column=1
  end statement:     line=2 column=35
  source code:       def subseq(s, b, e) returns result:
                     ^^^

Step 3:
  program counter:   54
  hvm code:          Push PC(57)
  explanation:       push constant PC(57)
  start statement:   line=11 column=1
  end statement:     line=11 column=24
  source code:       builtin tail "list$tail"
                             ^^^^
  stack:             [{:}, PC(57)]

Step 4:
  program counter:   55
  hvm code:          Builtin(list$tail)
  explanation:       pop pc () and bind to built-in method list$tail
  source code:       builtin tail "list$tail"
                     ^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}]

Step 5:
  program counter:   56
  hvm code:          Jump 602
  explanation:       jump over method definition: set program counter to 602
  start statement:   line=12 column=1
  end statement:     line=12 column=27
  source code:       def tail(s) returns result:
                     ^^^

Step 6:
  program counter:   602
  hvm code:          Push PC(605)
  explanation:       push constant PC(605)
  module:            bag
  start statement:   line=15 column=1
  end statement:     line=15 column=39
  source code:       builtin multiplicity "bag$multiplicity"
                             ^^^^^^^^^^^^
  stack:             [{:}, PC(605)]

Step 7:
  program counter:   603
  hvm code:          Builtin(bag$multiplicity)
  explanation:       pop pc () and bind to built-in method bag$multiplicity
  source code:       builtin multiplicity "bag$multiplicity"
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}]

Step 8:
  program counter:   604
  hvm code:          Jump 624
  explanation:       jump over method definition: set program counter to 624
  start statement:   line=16 column=1
  end statement:     line=16 column=40
  source code:       def multiplicity(bg, elt) returns count:
                     ^^^

Step 9:
  program counter:   624
  hvm code:          Push PC(627)
  explanation:       push constant PC(627)
  start statement:   line=22 column=1
  end statement:     line=22 column=23
  source code:       builtin size "bag$size"
                             ^^^^
  stack:             [{:}, PC(627)]

Step 10:
  program counter:   625
  hvm code:          Builtin(bag$size)
  explanation:       pop pc () and bind to built-in method bag$size
  source code:       builtin size "bag$size"
                     ^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}]

Step 11:
  program counter:   626
  hvm code:          Jump 646
  explanation:       jump over method definition: set program counter to 646
  start statement:   line=23 column=1
  end statement:     line=23 column=27
  source code:       def size(bg) returns count:
                     ^^^

Step 12:
  program counter:   646
  hvm code:          Push PC(649)
  explanation:       push constant PC(649)
  start statement:   line=28 column=1
  end statement:     line=28 column=23
  source code:       builtin bmin "bag$bmin"
                             ^^^^
  stack:             [{:}, PC(649)]

Step 13:
  program counter:   647
  hvm code:          Builtin(bag$bmin)
  explanation:       pop pc () and bind to built-in method bag$bmin
  source code:       builtin bmin "bag$bmin"
                     ^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}]

Step 14:
  program counter:   648
  hvm code:          Jump 665
  explanation:       jump over method definition: set program counter to 665
  start statement:   line=29 column=1
  end statement:     line=29 column=27
  source code:       def bmin(bg) returns count:
                     ^^^

Step 15:
  program counter:   665
  hvm code:          Push PC(668)
  explanation:       push constant PC(668)
  start statement:   line=33 column=1
  end statement:     line=33 column=23
  source code:       builtin bmax "bag$bmax"
                             ^^^^
  stack:             [{:}, PC(668)]

Step 16:
  program counter:   666
  hvm code:          Builtin(bag$bmax)
  explanation:       pop pc () and bind to built-in method bag$bmax
  source code:       builtin bmax "bag$bmax"
                     ^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}]

Step 17:
  program counter:   667
  hvm code:          Jump 693
  explanation:       jump over method definition: set program counter to 693
  start statement:   line=34 column=1
  end statement:     line=34 column=27
  source code:       def bmax(bg) returns count:
                     ^^^

Step 18:
  program counter:   693
  hvm code:          Push PC(696)
  explanation:       push constant PC(696)
  start statement:   line=41 column=1
  end statement:     line=41 column=21
  source code:       builtin add "bag$add"
                             ^^^
  stack:             [{:}, PC(696)]

Step 19:
  program counter:   694
  hvm code:          Builtin(bag$add)
  explanation:       pop pc () and bind to built-in method bag$add
  source code:       builtin add "bag$add"
                     ^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}]

Step 20:
  program counter:   695
  hvm code:          Jump 722
  explanation:       jump over method definition: set program counter to 722
  start statement:   line=42 column=1
  end statement:     line=42 column=32
  source code:       def add(bg, elt) returns result:
                     ^^^

Step 21:
  program counter:   722
  hvm code:          Push PC(725)
  explanation:       push constant PC(725)
  start statement:   line=49 column=1
  end statement:     line=49 column=27
  source code:       builtin remove "bag$remove"
                             ^^^^^^
  stack:             [{:}, PC(725)]

Step 22:
  program counter:   723
  hvm code:          Builtin(bag$remove)
  explanation:       pop pc () and bind to built-in method bag$remove
  source code:       builtin remove "bag$remove"
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}]

Step 23:
  program counter:   724
  hvm code:          Jump 1205
  explanation:       jump over method definition: set program counter to 1205
  start statement:   line=50 column=1
  end statement:     line=50 column=35
  source code:       def remove(bg, elt) returns result:
                     ^^^

Step 24:
  program counter:   1205
  hvm code:          Push {:}
  explanation:       push constant {:}
  module:            alloc
  start statement:   line=1 column=1
  end statement:     line=1 column=10
  source code:       pool = {:}
                            ^^^
  stack:             [{:}, {:}]

Step 25:
  program counter:   1206
  hvm code:          Store alloc$pool
  explanation:       pop value ({:}) and store into variable alloc$pool
  source code:       pool = {:}
                     ^^^^^^
  shared variables:  { alloc$pool: {:} }
  stack:             [{:}]

Step 26:
  program counter:   1207
  hvm code:          Push 0
  explanation:       push constant 0
  start statement:   line=2 column=1
  end statement:     line=2 column=8
  source code:       next = 0
                            ^
  stack:             [{:}, 0]

Step 27:
  program counter:   1208
  hvm code:          Store alloc$next
  explanation:       pop value (0) and store into variable alloc$next
  source code:       next = 0
                     ^^^^^^
  shared variables:  { alloc$next: 0, alloc$pool: {:} }
  stack:             [{:}]

Step 28:
  program counter:   1209
  hvm code:          Jump 1535
  explanation:       jump over method definition: set program counter to 1535
  start statement:   line=6 column=1
  end statement:     line=6 column=27
  source code:       def malloc(v) returns copy:
                     ^^^

Step 29:
  program counter:   1535
  hvm code:          Push PC(1250)
  explanation:       push program counter constant 1250 ()
  module:            __main__
  start statement:   line=31 column=1
  end statement:     line=31 column=17
  source code:       d = deque.Deque()
                         ^^^^^^^^^^^
  stack:             [{:}, PC(1250)]

Step 30:
  program counter:   1536
  hvm code:          Push ()
  explanation:       push constant ()
  source code:       d = deque.Deque()
                                    ^^
  stack:             [{:}, PC(1250), []]

Step 31:
  program counter:   1537
  hvm code:          2-ary Closure
  explanation:       pop 2 values ([], PC(1250)); push result (?PC(1250)[[]])
  source code:       d = deque.Deque()
                         ^^^^^^^^^^^^^
  stack:             [{:}, ?PC(1250)[[]]]

Step 32:
  program counter:   1538
  hvm code:          Load
  explanation:       pop an argument ([]) and call method (1250: "Deque")
  start expression:  line=31 column=5
  end expression:    line=31 column=17
  call trace:        __init__() --> Deque()
  stack:             [{:}, [], 24610, []]

Step 33:
  program counter:   1250
  hvm code:          Frame Deque()
  explanation:       pop argument () and run method "Deque"
  module:            deque
  start statement:   line=4 column=1
  end statement:     line=4 column=26
  source code:       def Deque() returns empty:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 24610, {:}]

Step 34:
  program counter:   1251
  hvm code:          Push {:}
  explanation:       push constant {:}
  start statement:   line=5 column=5
  end statement:     line=5 column=54
  source code:       empty = { .head: None, .tail: None, .lock: Lock()}
                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 24610, {:}, {:}]

Step 35:
  program counter:   1252
  hvm code:          Push "head"
  explanation:       push constant "head"
  source code:       empty = { .head: None, .tail: None, .lock: Lock()}
                               ^^^^^
  stack:             [{:}, [], 24610, {:}, {:}, "head"]

Step 36:
  program counter:   1253
  hvm code:          Push None
  explanation:       push constant None
  source code:       empty = { .head: None, .tail: None, .lock: Lock()}
                                      ^^^^
  stack:             [{:}, [], 24610, {:}, {:}, "head", None]

Step 37:
  program counter:   1254
  hvm code:          3-ary DictAdd
  explanation:       pop 3 values (None, "head", {:}); add key/value pair to dictionary; push result ({ "head": None })
  source code:       empty = { .head: None, .tail: None, .lock: Lock()}
                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 24610, {:}, { "head": None }]

Step 38:
  program counter:   1255
  hvm code:          Push "tail"
  explanation:       push constant "tail"
  source code:       empty = { .head: None, .tail: None, .lock: Lock()}
                                            ^^^^^
  stack:             [{:}, [], 24610, {:}, { "head": None }, "tail"]

Step 39:
  program counter:   1256
  hvm code:          Push None
  explanation:       push constant None
  source code:       empty = { .head: None, .tail: None, .lock: Lock()}
                                                   ^^^^
  stack:             [{:}, [], 24610, {:}, { "head": None }, "tail", None]

Step 40:
  program counter:   1257
  hvm code:          3-ary DictAdd
  explanation:       pop 3 values (None, "tail", { "head": None }); add key/value pair to dictionary; push result ({ "head": None, "tail": None })
  source code:       empty = { .head: None, .tail: None, .lock: Lock()}
                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 24610, {:}, { "head": None, "tail": None }]

Step 41:
  program counter:   1258
  hvm code:          Push "lock"
  explanation:       push constant "lock"
  source code:       empty = { .head: None, .tail: None, .lock: Lock()}
                                                         ^^^^^
  stack:             [{:}, [], 24610, {:}, { "head": None, "tail": None }, "lock"]

Step 42:
  program counter:   1259
  hvm code:          Push ()
  explanation:       push constant ()
  source code:       empty = { .head: None, .tail: None, .lock: Lock()}
                                                                    ^^
  stack:             [{:}, [], 24610, {:}, { "head": None, "tail": None }, "lock", []]

Step 43:
  program counter:   1260
  hvm code:          Apply PC(931)
  explanation:       pop an argument ([]) and call method (931: "Lock")
  source code:       empty = { .head: None, .tail: None, .lock: Lock()}
                                                                ^^^^^^
  call trace:        __init__() --> Deque() --> Lock()
  stack:             [{:}, [], 24610, {:}, { "head": None, "tail": None }, "lock", [], 20162, []]

Step 44:
  program counter:   931
  hvm code:          Frame Lock()
  explanation:       pop argument () and run method "Lock"
  module:            synch
  start statement:   line=25 column=1
  end statement:     line=25 column=26
  source code:       def Lock() returns result:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 24610, {:}, { "head": None, "tail": None }, "lock", [], 20162, {:}]

Step 45:
  program counter:   932
  hvm code:          DelVar result
  explanation:       delete method variable result
  start statement:   line=26 column=5
  end statement:     line=26 column=27
  source code:       result = BinSema(False)
                                      ^^^^^

Step 46:
  program counter:   933
  hvm code:          Push False
  explanation:       push constant False
  start expression:  line=26 column=22
  end expression:    line=26 column=26
  stack:             [{:}, [], 24610, {:}, { "head": None, "tail": None }, "lock", [], 20162, {:}, False]

Step 47:
  program counter:   934
  hvm code:          Apply PC(912)
  explanation:       pop an argument (False) and call method (912: "BinSema")
  source code:       result = BinSema(False)
                              ^^^^^^^^^^^^^^
  call trace:        __init__() --> Deque() --> Lock() --> BinSema(False)
  stack:             [{:}, [], 24610, {:}, { "head": None, "tail": None }, "lock", [], 20162, {:}, [], 14946, False]

Step 48:
  program counter:   912
  hvm code:          Frame BinSema(initial)
  explanation:       pop argument (False), assign to initial, and run method "BinSema"
  start statement:   line=21 column=1
  end statement:     line=21 column=34
  source code:       def BinSema(initial) returns sema:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { initial: False }
  stack:             [{:}, [], 24610, {:}, { "head": None, "tail": None }, "lock", [], 20162, {:}, [], 14946, {:}]

Step 49:
  program counter:   913
  hvm code:          AtomicInc(lazy)
  explanation:       increment atomic counter from 1 to 2: remains atomic
  start statement:   line=22 column=5
  end statement:     line=22 column=37
  source code:       assert initial in { False, True }
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Step 50:
  program counter:   914
  hvm code:          ReadonlyInc
  explanation:       increment readonly counter from 0 to 1: becomes readonly
  start expression:  line=22 column=5
  end expression:    line=22 column=37

Step 51:
  program counter:   915
  hvm code:          LoadVar initial
  explanation:       push value (False) of variable "initial"
  source code:       assert initial in { False, True }
                            ^^^^^^^
  stack:             [{:}, [], 24610, {:}, { "head": None, "tail": None }, "lock", [], 20162, {:}, [], 14946, {:}, False]

Step 52:
  program counter:   916
  hvm code:          Push {}
  explanation:       push constant {}
  source code:       assert initial in { False, True }
                                         ^^^^^^^^^^^
  stack:             [{:}, [], 24610, {:}, { "head": None, "tail": None }, "lock", [], 20162, {:}, [], 14946, {:}, False, {}]

Step 53:
  program counter:   917
  hvm code:          Push False
  explanation:       push constant False
  source code:       assert initial in { False, True }
                                         ^^^^^
  stack:             [{:}, [], 24610, {:}, { "head": None, "tail": None }, "lock", [], 20162, {:}, [], 14946, {:}, False, {}, False]

Step 54:
  program counter:   918
  hvm code:          2-ary SetAdd
  explanation:       pop 2 values (False, {}); insert first value into the second; push result ({ False })
  source code:       assert initial in { False, True }
                                         ^^^^^^^^^^^
  stack:             [{:}, [], 24610, {:}, { "head": None, "tail": None }, "lock", [], 20162, {:}, [], 14946, {:}, False, { False }]

Step 55:
  program counter:   919
  hvm code:          Push True
  explanation:       push constant True
  source code:       assert initial in { False, True }
                                                ^^^^
  stack:             [{:}, [], 24610, {:}, { "head": None, "tail": None }, "lock", [], 20162, {:}, [], 14946, {:}, False, { False }, True]

Step 56:
  program counter:   920
  hvm code:          2-ary SetAdd
  explanation:       pop 2 values (True, { False }); insert first value into the second; push result ({ False, True })
  source code:       assert initial in { False, True }
                                         ^^^^^^^^^^^
  stack:             [{:}, [], 24610, {:}, { "head": None, "tail": None }, "lock", [], 20162, {:}, [], 14946, {:}, False, { False, True }]

Step 57:
  program counter:   921
  hvm code:          2-ary in
  explanation:       pop 2 values ({ False, True }, False); check if the second value is a member of the first; push result (True)
  source code:       assert initial in { False, True }
                            ^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 24610, {:}, { "head": None, "tail": None }, "lock", [], 20162, {:}, [], 14946, {:}, True]

Step 58:
  program counter:   922
  hvm code:          Assert
  explanation:       pop a value (True); do not raise exception
  source code:       assert initial in { False, True }
                     ^^^^^^
  stack:             [{:}, [], 24610, {:}, { "head": None, "tail": None }, "lock", [], 20162, {:}, [], 14946, {:}]

Step 59:
  program counter:   923
  hvm code:          ReadonlyDec
  explanation:       decrement readonly counter from 1 to 0: no longer readonly
  source code:       assert initial in { False, True }
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Step 60:
  program counter:   924
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 2 to 1: remains atomic
  start expression:  line=22 column=5
  end expression:    line=22 column=37

Step 61:
  program counter:   925
  hvm code:          LoadVar initial
  explanation:       push value (False) of variable "initial"
  start statement:   line=23 column=5
  end statement:     line=23 column=18
  source code:       sema = initial
                            ^^^^^^^
  stack:             [{:}, [], 24610, {:}, { "head": None, "tail": None }, "lock", [], 20162, {:}, [], 14946, {:}, False]

Step 62:
  program counter:   926
  hvm code:          DelVar initial
  explanation:       delete method variable initial
  start expression:  line=23 column=12
  end expression:    line=23 column=18
  method variables:  { }

Step 63:
  program counter:   927
  hvm code:          StoreVar sema
  explanation:       pop value (False) and store locally in variable \"sema\"
  source code:       sema = initial
                     ^^^^^^
  method variables:  { sema: False }
  stack:             [{:}, [], 24610, {:}, { "head": None, "tail": None }, "lock", [], 20162, {:}, [], 14946, {:}]

Step 64:
  program counter:   928
  hvm code:          ReturnOp(sema)
  explanation:       pop caller's method variables and pc and push result (), or terminate if no caller
  start statement:   line=21 column=1
  end statement:     line=21 column=34
  source code:       def BinSema(initial) returns sema:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { }
  call trace:        __init__() --> Deque() --> Lock()
  stack:             [{:}, [], 24610, {:}, { "head": None, "tail": None }, "lock", [], 20162, {:}, False]

Step 65:
  program counter:   935
  hvm code:          StoreVar result
  explanation:       pop value (False) and store locally in variable \"result\"
  start statement:   line=26 column=5
  end statement:     line=26 column=27
  source code:       result = BinSema(False)
                     ^^^^^^^^
  method variables:  { result: False }
  stack:             [{:}, [], 24610, {:}, { "head": None, "tail": None }, "lock", [], 20162, {:}]

Step 66:
  program counter:   936
  hvm code:          ReturnOp(result)
  explanation:       pop caller's method variables and pc and push result (), or terminate if no caller
  start statement:   line=25 column=1
  end statement:     line=25 column=26
  source code:       def Lock() returns result:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { }
  call trace:        __init__() --> Deque()
  stack:             [{:}, [], 24610, {:}, { "head": None, "tail": None }, "lock", False]

Step 67:
  program counter:   1261
  hvm code:          3-ary DictAdd
  explanation:       pop 3 values (False, "lock", { "head": None, "tail": None }); add key/value pair to dictionary; push result ({ "head": None, "lock": False, "tail": None })
  module:            deque
  start statement:   line=5 column=5
  end statement:     line=5 column=54
  source code:       empty = { .head: None, .tail: None, .lock: Lock()}
                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 24610, {:}, { "head": None, "lock": False, "tail": None }]

Step 68:
  program counter:   1262
  hvm code:          StoreVar empty
  explanation:       pop value ({ "head": None, "lock": False, "tail": None }) and store locally in variable \"empty\"
  source code:       empty = { .head: None, .tail: None, .lock: Lock()}
                     ^^^^^^^
  method variables:  { empty: { "head": None, "lock": False, "tail": None } }
  stack:             [{:}, [], 24610, {:}]

Step 69:
  program counter:   1263
  hvm code:          ReturnOp(empty)
  explanation:       pop caller's method variables and pc and push result (), or terminate if no caller
  start statement:   line=4 column=1
  end statement:     line=4 column=26
  source code:       def Deque() returns empty:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { }
  call trace:        __init__()
  stack:             [{:}, { "head": None, "lock": False, "tail": None }]

Step 70:
  program counter:   1539
  hvm code:          Store d
  explanation:       pop value ({ "head": None, "lock": False, "tail": None }) and store into variable d
  module:            __main__
  start statement:   line=31 column=1
  end statement:     line=31 column=17
  source code:       d = deque.Deque()
                     ^^^
  shared variables:  { alloc$next: 0, alloc$pool: {:}, d: { "head": None, "lock": False, "tail": None } }
  stack:             [{:}]

Step 71:
  program counter:   1540
  hvm code:          Jump 1662
  explanation:       jump over method definition: set program counter to 1662
  start statement:   line=33 column=1
  end statement:     line=33 column=24
  source code:       def put_left_test(self):
                     ^^^

Step 72:
  program counter:   1662
  hvm code:          Push 1
  explanation:       push constant 1
  start statement:   line=54 column=1
  end statement:     line=54 column=24
  source code:       for i in {1..N_PUT_LEFT}:
                               ^
  stack:             [{:}, 1]

Step 73:
  program counter:   1663
  hvm code:          Push 2
  explanation:       push constant 2
  source code:       for i in {1..N_PUT_LEFT}:
                                  ^^^^^^^^^^
  stack:             [{:}, 1, 2]

Step 74:
  program counter:   1664
  hvm code:          2-ary ..
  explanation:       pop 2 values (2, 1); range of integers; push result ({ 1, 2 })
  source code:       for i in {1..N_PUT_LEFT}:
                               ^^^^^^^^^^^^^
  stack:             [{:}, { 1, 2 }]

Step 75:
  program counter:   1665
  hvm code:          Push 0
  explanation:       push constant 0
  source code:       for i in {1..N_PUT_LEFT}:
                     ^^^
  stack:             [{:}, { 1, 2 }, 0]

Step 76:
  program counter:   1666
  hvm code:          Cut(i)
  explanation:       pop index (0) and value ({ 1, 2 }); assign value (1) to i; push new index (1) and True
  start expression:  line=54 column=1
  end expression:    line=54 column=3
  method variables:  { i: 1 }
  stack:             [{:}, { 1, 2 }, 1, True]

Step 77:
  program counter:   1667
  hvm code:          JumpCond False 1675
  explanation:       pop value (True), compare to False, and jump to 1675 if the same
  start expression:  line=54 column=1
  end expression:    line=54 column=3
  stack:             [{:}, { 1, 2 }, 1]

Step 78:
  program counter:   1668
  hvm code:          Push ?PC(1541)
  explanation:       push constant ?PC(1541)
  start statement:   line=55 column=5
  end statement:     line=55 column=26
  source code:       spawn put_left_test(i)
                           ^^^^^^^^^^^^^
  stack:             [{:}, { 1, 2 }, 1, ?PC(1541)]

Step 79:
  program counter:   1669
  hvm code:          LoadVar i
  explanation:       push value (1) of variable "i"
  source code:       spawn put_left_test(i)
                                         ^
  stack:             [{:}, { 1, 2 }, 1, ?PC(1541), 1]

Step 80:
  program counter:   1670
  hvm code:          DelVar i
  explanation:       delete method variable i
  start expression:  line=55 column=25
  end expression:    line=55 column=25
  method variables:  { }

Step 81:
  program counter:   1671
  hvm code:          2-ary AddArg
  explanation:       pop 2 values (1, ?PC(1541)); push result (?PC(1541)[1])
  source code:       spawn put_left_test(i)
                           ^^^^^^^^^^^^^^^^
  stack:             [{:}, { 1, 2 }, 1, ?PC(1541)[1]]

Step 82:
  program counter:   1672
  hvm code:          Push {:}
  explanation:       push constant {:}
  source code:       spawn put_left_test(i)
                     ^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, { 1, 2 }, 1, ?PC(1541)[1], {:}]

Step 83:
  program counter:   1673
  hvm code:          Spawn
  explanation:       pop local state ({:}), arg (1), and pc (1541: "put_left_test"), and spawn thread
  start expression:  line=55 column=5
  end expression:    line=55 column=26
  stack:             [{:}, { 1, 2 }, 1]

Step 84:
  program counter:   1674
  hvm code:          Jump 1666
  explanation:       set program counter to 1666
  start statement:   line=54 column=1
  end statement:     line=54 column=24
  source code:       for i in {1..N_PUT_LEFT}:
                                            ^

Step 85:
  program counter:   1666
  hvm code:          Cut(i)
  explanation:       pop index (1) and value ({ 1, 2 }); assign value (2) to i; push new index (2) and True
  source code:       for i in {1..N_PUT_LEFT}:
                     ^^^
  method variables:  { i: 2 }
  stack:             [{:}, { 1, 2 }, 2, True]

Step 86:
  program counter:   1667
  hvm code:          JumpCond False 1675
  explanation:       pop value (True), compare to False, and jump to 1675 if the same
  start expression:  line=54 column=1
  end expression:    line=54 column=3
  stack:             [{:}, { 1, 2 }, 2]

Step 87:
  program counter:   1668
  hvm code:          Push ?PC(1541)
  explanation:       push constant ?PC(1541)
  start statement:   line=55 column=5
  end statement:     line=55 column=26
  source code:       spawn put_left_test(i)
                           ^^^^^^^^^^^^^
  stack:             [{:}, { 1, 2 }, 2, ?PC(1541)]

Step 88:
  program counter:   1669
  hvm code:          LoadVar i
  explanation:       push value (2) of variable "i"
  source code:       spawn put_left_test(i)
                                         ^
  stack:             [{:}, { 1, 2 }, 2, ?PC(1541), 2]

Step 89:
  program counter:   1670
  hvm code:          DelVar i
  explanation:       delete method variable i
  start expression:  line=55 column=25
  end expression:    line=55 column=25
  method variables:  { }

Step 90:
  program counter:   1671
  hvm code:          2-ary AddArg
  explanation:       pop 2 values (2, ?PC(1541)); push result (?PC(1541)[2])
  source code:       spawn put_left_test(i)
                           ^^^^^^^^^^^^^^^^
  stack:             [{:}, { 1, 2 }, 2, ?PC(1541)[2]]

Step 91:
  program counter:   1672
  hvm code:          Push {:}
  explanation:       push constant {:}
  source code:       spawn put_left_test(i)
                     ^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, { 1, 2 }, 2, ?PC(1541)[2], {:}]

Step 92:
  program counter:   1673
  hvm code:          Spawn
  explanation:       pop local state ({:}), arg (2), and pc (1541: "put_left_test"), and spawn thread
  start expression:  line=55 column=5
  end expression:    line=55 column=26
  stack:             [{:}, { 1, 2 }, 2]

Step 93:
  program counter:   1674
  hvm code:          Jump 1666
  explanation:       set program counter to 1666
  start statement:   line=54 column=1
  end statement:     line=54 column=24
  source code:       for i in {1..N_PUT_LEFT}:
                                            ^

Step 94:
  program counter:   1666
  hvm code:          Cut(i)
  explanation:       pop index (2) and value ({ 1, 2 }); out of range -> push False
  source code:       for i in {1..N_PUT_LEFT}:
                     ^^^
  stack:             [{:}, False]

Step 95:
  program counter:   1667
  hvm code:          JumpCond False 1675
  explanation:       pop value (False), compare to False, and jump to 1675 if the same
  start expression:  line=54 column=1
  end expression:    line=54 column=3
  stack:             [{:}]

Step 96:
  program counter:   1675
  hvm code:          DelVar i
  explanation:       delete method variable i
  start statement:   line=57 column=1
  end statement:     line=57 column=25
  source code:       for i in {1..N_PUT_RIGHT}:
                               ^

Step 97:
  program counter:   1676
  hvm code:          Push 1
  explanation:       push constant 1
  start expression:  line=57 column=11
  end expression:    line=57 column=11
  stack:             [{:}, 1]

Step 98:
  program counter:   1677
  hvm code:          Push 2
  explanation:       push constant 2
  source code:       for i in {1..N_PUT_RIGHT}:
                                  ^^^^^^^^^^^
  stack:             [{:}, 1, 2]

Step 99:
  program counter:   1678
  hvm code:          2-ary ..
  explanation:       pop 2 values (2, 1); range of integers; push result ({ 1, 2 })
  source code:       for i in {1..N_PUT_RIGHT}:
                               ^^^^^^^^^^^^^^
  stack:             [{:}, { 1, 2 }]

Step 100:
  program counter:   1679
  hvm code:          Push 0
  explanation:       push constant 0
  source code:       for i in {1..N_PUT_RIGHT}:
                     ^^^
  stack:             [{:}, { 1, 2 }, 0]

Step 101:
  program counter:   1680
  hvm code:          Cut(i)
  explanation:       pop index (0) and value ({ 1, 2 }); assign value (1) to i; push new index (1) and True
  start expression:  line=57 column=1
  end expression:    line=57 column=3
  method variables:  { i: 1 }
  stack:             [{:}, { 1, 2 }, 1, True]

Step 102:
  program counter:   1681
  hvm code:          JumpCond False 1689
  explanation:       pop value (True), compare to False, and jump to 1689 if the same
  start expression:  line=57 column=1
  end expression:    line=57 column=3
  stack:             [{:}, { 1, 2 }, 1]

Step 103:
  program counter:   1682
  hvm code:          Push ?PC(1578)
  explanation:       push constant ?PC(1578)
  start statement:   line=58 column=5
  end statement:     line=58 column=27
  source code:       spawn put_right_test(i)
                           ^^^^^^^^^^^^^^
  stack:             [{:}, { 1, 2 }, 1, ?PC(1578)]

Step 104:
  program counter:   1683
  hvm code:          LoadVar i
  explanation:       push value (1) of variable "i"
  source code:       spawn put_right_test(i)
                                          ^
  stack:             [{:}, { 1, 2 }, 1, ?PC(1578), 1]

Step 105:
  program counter:   1684
  hvm code:          DelVar i
  explanation:       delete method variable i
  start expression:  line=58 column=26
  end expression:    line=58 column=26
  method variables:  { }

Step 106:
  program counter:   1685
  hvm code:          2-ary AddArg
  explanation:       pop 2 values (1, ?PC(1578)); push result (?PC(1578)[1])
  source code:       spawn put_right_test(i)
                           ^^^^^^^^^^^^^^^^^
  stack:             [{:}, { 1, 2 }, 1, ?PC(1578)[1]]

Step 107:
  program counter:   1686
  hvm code:          Push {:}
  explanation:       push constant {:}
  source code:       spawn put_right_test(i)
                     ^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, { 1, 2 }, 1, ?PC(1578)[1], {:}]

Step 108:
  program counter:   1687
  hvm code:          Spawn
  explanation:       pop local state ({:}), arg (1), and pc (1578: "put_right_test"), and spawn thread
  start expression:  line=58 column=5
  end expression:    line=58 column=27
  stack:             [{:}, { 1, 2 }, 1]

Step 109:
  program counter:   1688
  hvm code:          Jump 1680
  explanation:       set program counter to 1680
  start statement:   line=57 column=1
  end statement:     line=57 column=25
  source code:       for i in {1..N_PUT_RIGHT}:
                                             ^

Step 110:
  program counter:   1680
  hvm code:          Cut(i)
  explanation:       pop index (1) and value ({ 1, 2 }); assign value (2) to i; push new index (2) and True
  source code:       for i in {1..N_PUT_RIGHT}:
                     ^^^
  method variables:  { i: 2 }
  stack:             [{:}, { 1, 2 }, 2, True]

Step 111:
  program counter:   1681
  hvm code:          JumpCond False 1689
  explanation:       pop value (True), compare to False, and jump to 1689 if the same
  start expression:  line=57 column=1
  end expression:    line=57 column=3
  stack:             [{:}, { 1, 2 }, 2]

Step 112:
  program counter:   1682
  hvm code:          Push ?PC(1578)
  explanation:       push constant ?PC(1578)
  start statement:   line=58 column=5
  end statement:     line=58 column=27
  source code:       spawn put_right_test(i)
                           ^^^^^^^^^^^^^^
  stack:             [{:}, { 1, 2 }, 2, ?PC(1578)]

Step 113:
  program counter:   1683
  hvm code:          LoadVar i
  explanation:       push value (2) of variable "i"
  source code:       spawn put_right_test(i)
                                          ^
  stack:             [{:}, { 1, 2 }, 2, ?PC(1578), 2]

Step 114:
  program counter:   1684
  hvm code:          DelVar i
  explanation:       delete method variable i
  start expression:  line=58 column=26
  end expression:    line=58 column=26
  method variables:  { }

Step 115:
  program counter:   1685
  hvm code:          2-ary AddArg
  explanation:       pop 2 values (2, ?PC(1578)); push result (?PC(1578)[2])
  source code:       spawn put_right_test(i)
                           ^^^^^^^^^^^^^^^^^
  stack:             [{:}, { 1, 2 }, 2, ?PC(1578)[2]]

Step 116:
  program counter:   1686
  hvm code:          Push {:}
  explanation:       push constant {:}
  source code:       spawn put_right_test(i)
                     ^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, { 1, 2 }, 2, ?PC(1578)[2], {:}]

Step 117:
  program counter:   1687
  hvm code:          Spawn
  explanation:       pop local state ({:}), arg (2), and pc (1578: "put_right_test"), and spawn thread
  start expression:  line=58 column=5
  end expression:    line=58 column=27
  stack:             [{:}, { 1, 2 }, 2]

Step 118:
  program counter:   1688
  hvm code:          Jump 1680
  explanation:       set program counter to 1680
  start statement:   line=57 column=1
  end statement:     line=57 column=25
  source code:       for i in {1..N_PUT_RIGHT}:
                                             ^

Step 119:
  program counter:   1680
  hvm code:          Cut(i)
  explanation:       pop index (2) and value ({ 1, 2 }); out of range -> push False
  source code:       for i in {1..N_PUT_RIGHT}:
                     ^^^
  stack:             [{:}, False]

Step 120:
  program counter:   1681
  hvm code:          JumpCond False 1689
  explanation:       pop value (False), compare to False, and jump to 1689 if the same
  start expression:  line=57 column=1
  end expression:    line=57 column=3
  stack:             [{:}]

Step 121:
  program counter:   1689
  hvm code:          DelVar i
  explanation:       delete method variable i
  start statement:   line=60 column=1
  end statement:     line=60 column=24
  source code:       for i in {1..N_GET_LEFT}:
                               ^

Step 122:
  program counter:   1690
  hvm code:          Push 1
  explanation:       push constant 1
  start expression:  line=60 column=11
  end expression:    line=60 column=11
  stack:             [{:}, 1]

Step 123:
  program counter:   1691
  hvm code:          Push 1
  explanation:       push constant 1
  source code:       for i in {1..N_GET_LEFT}:
                                  ^^^^^^^^^^
  stack:             [{:}, 1, 1]

Step 124:
  program counter:   1692
  hvm code:          2-ary ..
  explanation:       pop 2 values (1, 1); range of integers; push result ({ 1 })
  source code:       for i in {1..N_GET_LEFT}:
                               ^^^^^^^^^^^^^
  stack:             [{:}, { 1 }]

Step 125:
  program counter:   1693
  hvm code:          Push 0
  explanation:       push constant 0
  source code:       for i in {1..N_GET_LEFT}:
                     ^^^
  stack:             [{:}, { 1 }, 0]

Step 126:
  program counter:   1694
  hvm code:          Cut(i)
  explanation:       pop index (0) and value ({ 1 }); assign value (1) to i; push new index (1) and True
  start expression:  line=60 column=1
  end expression:    line=60 column=3
  method variables:  { i: 1 }
  stack:             [{:}, { 1 }, 1, True]

Step 127:
  program counter:   1695
  hvm code:          JumpCond False 1703
  explanation:       pop value (True), compare to False, and jump to 1703 if the same
  start expression:  line=60 column=1
  end expression:    line=60 column=3
  stack:             [{:}, { 1 }, 1]

Step 128:
  program counter:   1696
  hvm code:          Push ?PC(1615)
  explanation:       push constant ?PC(1615)
  start statement:   line=61 column=5
  end statement:     line=61 column=26
  source code:       spawn get_left_test(i)
                           ^^^^^^^^^^^^^
  stack:             [{:}, { 1 }, 1, ?PC(1615)]

Step 129:
  program counter:   1697
  hvm code:          LoadVar i
  explanation:       push value (1) of variable "i"
  source code:       spawn get_left_test(i)
                                         ^
  stack:             [{:}, { 1 }, 1, ?PC(1615), 1]

Step 130:
  program counter:   1698
  hvm code:          DelVar i
  explanation:       delete method variable i
  start expression:  line=61 column=25
  end expression:    line=61 column=25
  method variables:  { }

Step 131:
  program counter:   1699
  hvm code:          2-ary AddArg
  explanation:       pop 2 values (1, ?PC(1615)); push result (?PC(1615)[1])
  source code:       spawn get_left_test(i)
                           ^^^^^^^^^^^^^^^^
  stack:             [{:}, { 1 }, 1, ?PC(1615)[1]]

Step 132:
  program counter:   1700
  hvm code:          Push {:}
  explanation:       push constant {:}
  source code:       spawn get_left_test(i)
                     ^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, { 1 }, 1, ?PC(1615)[1], {:}]

Step 133:
  program counter:   1701
  hvm code:          Spawn
  explanation:       pop local state ({:}), arg (1), and pc (1615: "get_left_test"), and spawn thread
  start expression:  line=61 column=5
  end expression:    line=61 column=26
  stack:             [{:}, { 1 }, 1]

Step 134:
  program counter:   1702
  hvm code:          Jump 1694
  explanation:       set program counter to 1694
  start statement:   line=60 column=1
  end statement:     line=60 column=24
  source code:       for i in {1..N_GET_LEFT}:
                                            ^

Step 135:
  program counter:   1694
  hvm code:          Cut(i)
  explanation:       pop index (1) and value ({ 1 }); out of range -> push False
  source code:       for i in {1..N_GET_LEFT}:
                     ^^^
  stack:             [{:}, False]

Step 136:
  program counter:   1695
  hvm code:          JumpCond False 1703
  explanation:       pop value (False), compare to False, and jump to 1703 if the same
  start expression:  line=60 column=1
  end expression:    line=60 column=3
  stack:             [{:}]

Step 137:
  program counter:   1703
  hvm code:          DelVar i
  explanation:       delete method variable i
  start statement:   line=63 column=1
  end statement:     line=63 column=25
  source code:       for i in {1..N_GET_RIGHT}:
                               ^

Step 138:
  program counter:   1704
  hvm code:          Push 1
  explanation:       push constant 1
  start expression:  line=63 column=11
  end expression:    line=63 column=11
  stack:             [{:}, 1]

Step 139:
  program counter:   1705
  hvm code:          Push 1
  explanation:       push constant 1
  source code:       for i in {1..N_GET_RIGHT}:
                                  ^^^^^^^^^^^
  stack:             [{:}, 1, 1]

Step 140:
  program counter:   1706
  hvm code:          2-ary ..
  explanation:       pop 2 values (1, 1); range of integers; push result ({ 1 })
  source code:       for i in {1..N_GET_RIGHT}:
                               ^^^^^^^^^^^^^^
  stack:             [{:}, { 1 }]

Step 141:
  program counter:   1707
  hvm code:          Push 0
  explanation:       push constant 0
  source code:       for i in {1..N_GET_RIGHT}:
                     ^^^
  stack:             [{:}, { 1 }, 0]

Step 142:
  program counter:   1708
  hvm code:          Cut(i)
  explanation:       pop index (0) and value ({ 1 }); assign value (1) to i; push new index (1) and True
  start expression:  line=63 column=1
  end expression:    line=63 column=3
  method variables:  { i: 1 }
  stack:             [{:}, { 1 }, 1, True]

Step 143:
  program counter:   1709
  hvm code:          JumpCond False 1717
  explanation:       pop value (True), compare to False, and jump to 1717 if the same
  start expression:  line=63 column=1
  end expression:    line=63 column=3
  stack:             [{:}, { 1 }, 1]

Step 144:
  program counter:   1710
  hvm code:          Push ?PC(1639)
  explanation:       push constant ?PC(1639)
  start statement:   line=64 column=5
  end statement:     line=64 column=27
  source code:       spawn get_right_test(i)
                           ^^^^^^^^^^^^^^
  stack:             [{:}, { 1 }, 1, ?PC(1639)]

Step 145:
  program counter:   1711
  hvm code:          LoadVar i
  explanation:       push value (1) of variable "i"
  source code:       spawn get_right_test(i)
                                          ^
  stack:             [{:}, { 1 }, 1, ?PC(1639), 1]

Step 146:
  program counter:   1712
  hvm code:          DelVar i
  explanation:       delete method variable i
  start expression:  line=64 column=26
  end expression:    line=64 column=26
  method variables:  { }

Step 147:
  program counter:   1713
  hvm code:          2-ary AddArg
  explanation:       pop 2 values (1, ?PC(1639)); push result (?PC(1639)[1])
  source code:       spawn get_right_test(i)
                           ^^^^^^^^^^^^^^^^^
  stack:             [{:}, { 1 }, 1, ?PC(1639)[1]]

Step 148:
  program counter:   1714
  hvm code:          Push {:}
  explanation:       push constant {:}
  source code:       spawn get_right_test(i)
                     ^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, { 1 }, 1, ?PC(1639)[1], {:}]

Step 149:
  program counter:   1715
  hvm code:          Spawn
  explanation:       pop local state ({:}), arg (1), and pc (1639: "get_right_test"), and spawn thread
  start expression:  line=64 column=5
  end expression:    line=64 column=27
  stack:             [{:}, { 1 }, 1]

Step 150:
  program counter:   1716
  hvm code:          Jump 1708
  explanation:       set program counter to 1708
  start statement:   line=63 column=1
  end statement:     line=63 column=25
  source code:       for i in {1..N_GET_RIGHT}:
                                             ^

Step 151:
  program counter:   1708
  hvm code:          Cut(i)
  explanation:       pop index (1) and value ({ 1 }); out of range -> push False
  source code:       for i in {1..N_GET_RIGHT}:
                     ^^^
  stack:             [{:}, False]

Step 152:
  program counter:   1709
  hvm code:          JumpCond False 1717
  explanation:       pop value (False), compare to False, and jump to 1717 if the same
  start expression:  line=63 column=1
  end expression:    line=63 column=3
  stack:             [{:}]

Step 153:
  program counter:   1717
  hvm code:          DelVar i
  explanation:       delete method variable i
  start statement:   line=25 column=1
  end statement:     line=67 column=6
  source code:       import deque

Step 154:
  program counter:   1718
  hvm code:          ReturnOp(result. None)
  explanation:       pop caller's method variables and pc and push result (), or terminate if no caller
  start expression:  line=25 column=1
  end expression:    line=67 column=6
  new mode:          terminated
  stack:             [None]

================================================
Running thread T2: put_left_test(2)
mode:  runnable
stack: ['2']
other threads:
  T0: pc=1718 terminated atomic __init__()
  T1: pc=1541 runnable put_left_test(1)
    about to run method put_left_test with argument 1
  T3: pc=1578 runnable put_right_test(1)
    about to run method put_right_test with argument 1
  T4: pc=1578 runnable put_right_test(2)
    about to run method put_right_test with argument 2
  T5: pc=1615 runnable get_left_test(1)
    about to run method get_left_test with argument 1
  T6: pc=1639 runnable get_right_test(1)
    about to run method get_right_test with argument 1
shared variables:
  alloc$next: 0
  alloc$pool: {:}
  d: { "head": None, "lock": False, "tail": None }
state id: 3
================================================

Step 155:
  program counter:   1541
  hvm code:          Frame put_left_test(self)
  explanation:       pop argument (2), assign to self, and run method "put_left_test"
  start statement:   line=33 column=1
  end statement:     line=33 column=24
  source code:       def put_left_test(self):
                     ^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { self: 2 }
  call trace:        put_left_test(2)
  stack:             [{:}]

Step 156:
  program counter:   1542
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  start statement:   line=34 column=5
  end statement:     line=34 column=41
  source code:       print("call put_left", (self,"left"))
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, []]

Step 157:
  program counter:   1543
  hvm code:          Push "call put_left"
  explanation:       push constant "call put_left"
  source code:       print("call put_left", (self,"left"))
                           ^^^^^^^^^^^^^^^
  stack:             [{:}, [], "call put_left"]

Step 158:
  program counter:   1544
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values ("call put_left", []); insert first value into the second; push result (["call put_left"])
  source code:       print("call put_left", (self,"left"))
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [ "call put_left" ]]

Step 159:
  program counter:   1545
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  source code:       print("call put_left", (self,"left"))
                                             ^^^^^^^^^^^
  stack:             [{:}, [ "call put_left" ], []]

Step 160:
  program counter:   1546
  hvm code:          LoadVar self
  explanation:       push value (2) of variable "self"
  source code:       print("call put_left", (self,"left"))
                                             ^^^^
  stack:             [{:}, [ "call put_left" ], [], 2]

Step 161:
  program counter:   1547
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (2, []); insert first value into the second; push result ([2])
  source code:       print("call put_left", (self,"left"))
                                             ^^^^^^^^^^^
  stack:             [{:}, [ "call put_left" ], [ 2 ]]

Step 162:
  program counter:   1548
  hvm code:          Push "left"
  explanation:       push constant "left"
  source code:       print("call put_left", (self,"left"))
                                                  ^^^^^^
  stack:             [{:}, [ "call put_left" ], [ 2 ], "left"]

Step 163:
  program counter:   1549
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values ("left", [2]); insert first value into the second; push result ([2, "left"])
  source code:       print("call put_left", (self,"left"))
                                             ^^^^^^^^^^^
  stack:             [{:}, [ "call put_left" ], [ 2, "left" ]]

Step 164:
  program counter:   1550
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values ([2, "left"], ["call put_left"]); insert first value into the second; push result (["call put_left", [2, "left"]])
  source code:       print("call put_left", (self,"left"))
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [ "call put_left", [ 2, "left" ] ]]

Step 165:
  program counter:   1551
  hvm code:          Print
  explanation:       pop value (["call put_left", [2, "left"]]) and add to print log
  source code:       print("call put_left", (self,"left"))
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  call trace:        put_left_test(2)
  stack:             [{:}]

Step 166:
  program counter:   1552
  hvm code:          Push PC(1266)
  explanation:       push program counter constant 1266 ()
  start statement:   line=35 column=5
  end statement:     line=35 column=37
  source code:       deque.put_left(?d, (self,"left"))
                     ^^^^^^^^^^^^^^
  stack:             [{:}, PC(1266)]

Step 167:
  program counter:   1553
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  source code:       deque.put_left(?d, (self,"left"))
                                    ^^^^^^^^^^^^^^^^^
  stack:             [{:}, PC(1266), []]

Step 168:
  program counter:   1554
  hvm code:          Push ?d
  explanation:       push constant ?d
  source code:       deque.put_left(?d, (self,"left"))
                                     ^
  stack:             [{:}, PC(1266), [], ?d]

Step 169:
  program counter:   1555
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (?d, []); insert first value into the second; push result ([?d])
  source code:       deque.put_left(?d, (self,"left"))
                                    ^^^^^^^^^^^^^^^^^
  stack:             [{:}, PC(1266), [ ?d ]]

Step 170:
  program counter:   1556
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  source code:       deque.put_left(?d, (self,"left"))
                                         ^^^^^^^^^^^
  stack:             [{:}, PC(1266), [ ?d ], []]

Step 171:
  program counter:   1557
  hvm code:          LoadVar self
  explanation:       push value (2) of variable "self"
  source code:       deque.put_left(?d, (self,"left"))
                                         ^^^^
  stack:             [{:}, PC(1266), [ ?d ], [], 2]

Step 172:
  program counter:   1558
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (2, []); insert first value into the second; push result ([2])
  source code:       deque.put_left(?d, (self,"left"))
                                         ^^^^^^^^^^^
  stack:             [{:}, PC(1266), [ ?d ], [ 2 ]]

Step 173:
  program counter:   1559
  hvm code:          Push "left"
  explanation:       push constant "left"
  source code:       deque.put_left(?d, (self,"left"))
                                              ^^^^^^
  stack:             [{:}, PC(1266), [ ?d ], [ 2 ], "left"]

Step 174:
  program counter:   1560
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values ("left", [2]); insert first value into the second; push result ([2, "left"])
  source code:       deque.put_left(?d, (self,"left"))
                                         ^^^^^^^^^^^
  stack:             [{:}, PC(1266), [ ?d ], [ 2, "left" ]]

Step 175:
  program counter:   1561
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values ([2, "left"], [?d]); insert first value into the second; push result ([?d, [2, "left"]])
  source code:       deque.put_left(?d, (self,"left"))
                                    ^^^^^^^^^^^^^^^^^
  stack:             [{:}, PC(1266), [ ?d, [ 2, "left" ] ]]

Step 176:
  program counter:   1562
  hvm code:          2-ary Closure
  explanation:       pop 2 values ([?d, [2, "left"]], PC(1266)); push result (?PC(1266)[[?d, [2, "left"]]])
  source code:       deque.put_left(?d, (self,"left"))
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, ?PC(1266)[[ ?d, [ 2, "left" ] ]]]

Step 177:
  program counter:   1563
  hvm code:          Load
  explanation:       pop an argument ([?d, [2, "left"]]) and call method (1266: "put_left")
  start expression:  line=35 column=5
  end expression:    line=35 column=37
  call trace:        put_left_test(2) --> put_left(?d, [2, "left"])
  stack:             [{:}, [], 25010, [ ?d, [ 2, "left" ] ]]

Step 178:
  program counter:   1266
  hvm code:          Frame put_left(d, v)
  explanation:       pop argument ([?d, [2, "left"]]), assign to (d, v), and run method "put_left"
  module:            deque
  start statement:   line=7 column=1
  end statement:     line=7 column=19
  source code:       def put_left(d, v):
                     ^^^^^^^^^^^^^^^^^^^
  method variables:  { d: ?d, v: [ 2, "left" ] }
  stack:             [{:}, [], 25010, { "self": 2 }]

Step 179:
  program counter:   1267
  hvm code:          LoadVar d
  explanation:       push value (?d) of variable "d"
  start statement:   line=13 column=5
  end statement:     line=13 column=21
  source code:       acquire(?d->lock)
                              ^
  stack:             [{:}, [], 25010, { "self": 2 }, ?d]

Step 180:
  program counter:   1268
  hvm code:          Push "lock"
  explanation:       push constant "lock"
  source code:       acquire(?d->lock)
                                 ^^^^
  stack:             [{:}, [], 25010, { "self": 2 }, ?d, "lock"]

Step 181:
  program counter:   1269
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("lock", ?d); push result (?d["lock"])
  source code:       acquire(?d->lock)
                              ^^^^^^^
  stack:             [{:}, [], 25010, { "self": 2 }, ?d["lock"]]

Step 182:
  program counter:   1270
  hvm code:          Apply PC(954)
  explanation:       pop an argument (?d["lock"]) and call method (954: "acquire")
  source code:       acquire(?d->lock)
                     ^^^^^^^^^^^^^^^^^
  call trace:        put_left_test(2) --> put_left(?d, [2, "left"]) --> acquire(?d["lock"])
  stack:             [{:}, [], 25010, { "self": 2 }, [], 20322, ?d["lock"]]

Step 183:
  program counter:   954
  hvm code:          Frame acquire(binsema)
  explanation:       pop argument (?d["lock"]), assign to binsema, and run method "acquire"
  module:            synch
  start statement:   line=34 column=1
  end statement:     line=34 column=21
  source code:       def acquire(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { binsema: ?d["lock"] }
  stack:             [{:}, [], 25010, { "self": 2 }, [], 20322, { "d": ?d, "v": [ 2, "left" ] }]

Step 184:
  program counter:   955
  hvm code:          AtomicInc(eager)
  explanation:       increment atomic counter from 0 to 1: becomes atomic
  start statement:   line=35 column=16
  end statement:     line=37 column=6
  source code:       atomically when not !binsema:
  call trace:        put_left_test(2) --> put_left(?d, [2, "left"]) --> acquire(?d["lock"])

Step 185:
  program counter:   956
  hvm code:          ReadonlyInc
  explanation:       increment readonly counter from 0 to 1: becomes readonly
  source code:       atomically when not !binsema:

Step 186:
  program counter:   957
  hvm code:          LoadVar binsema
  explanation:       push value (?d["lock"]) of variable "binsema"
  start statement:   line=35 column=16
  end statement:     line=35 column=32
  source code:       atomically when not !binsema:
                                          ^^^^^^^
  stack:             [{:}, [], 25010, { "self": 2 }, [], 20322, { "d": ?d, "v": [ 2, "left" ] }, ?d["lock"]]

Step 187:
  program counter:   958
  hvm code:          Load
  explanation:       pop address (?d["lock"]) and push value (False)
  source code:       atomically when not !binsema:
                                         ^^^^^^^^
  stack:             [{:}, [], 25010, { "self": 2 }, [], 20322, { "d": ?d, "v": [ 2, "left" ] }, False]

Step 188:
  program counter:   959
  hvm code:          1-ary not
  explanation:       pop a value (False); logical not; push result (True)
  source code:       atomically when not !binsema:
                                     ^^^^^^^^^^^^
  stack:             [{:}, [], 25010, { "self": 2 }, [], 20322, { "d": ?d, "v": [ 2, "left" ] }, True]

Step 189:
  program counter:   960
  hvm code:          JumpCond False 962
  explanation:       pop value (True), compare to False, and jump to 962 if the same
  source code:       atomically when not !binsema:
                                ^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 25010, { "self": 2 }, [], 20322, { "d": ?d, "v": [ 2, "left" ] }]

Step 190:
  program counter:   961
  hvm code:          Jump 965
  explanation:       set program counter to 965
  source code:       atomically when not !binsema:
                                                ^

Step 191:
  program counter:   965
  hvm code:          ReadonlyDec
  explanation:       decrement readonly counter from 1 to 0: no longer readonly
  source code:       atomically when not !binsema:
                                ^^^^^^^^^^^^^^^^^

Step 192:
  program counter:   966
  hvm code:          LoadVar binsema
  explanation:       push value (?d["lock"]) of variable "binsema"
  start statement:   line=36 column=9
  end statement:     line=36 column=23
  source code:       !binsema = True
                      ^^^^^^^
  stack:             [{:}, [], 25010, { "self": 2 }, [], 20322, { "d": ?d, "v": [ 2, "left" ] }, ?d["lock"]]

Step 193:
  program counter:   967
  hvm code:          DelVar binsema
  explanation:       delete method variable binsema
  start expression:  line=36 column=10
  end expression:    line=36 column=16
  method variables:  { }

Step 194:
  program counter:   968
  hvm code:          Push True
  explanation:       push constant True
  source code:       !binsema = True
                                ^^^^
  stack:             [{:}, [], 25010, { "self": 2 }, [], 20322, { "d": ?d, "v": [ 2, "left" ] }, ?d["lock"], True]

Step 195:
  program counter:   969
  hvm code:          Store
  explanation:       pop value (True) and address (?d["lock"]) and store
  source code:       !binsema = True
                     ^^^^^^^^^^
  shared variables:  { alloc$next: 0, alloc$pool: {:}, d: { "head": None, "lock": True, "tail": None } }
  stack:             [{:}, [], 25010, { "self": 2 }, [], 20322, { "d": ?d, "v": [ 2, "left" ] }]

Step 196:
  program counter:   970
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 1 to 0: no longer atomic
  start statement:   line=35 column=16
  end statement:     line=35 column=32
  source code:       atomically when not !binsema:
                                ^^^^^^^^^^^^^^^^^

Step 197:
  program counter:   971
  hvm code:          ReturnOp(result. None)
  explanation:       pop caller's method variables and pc and push result (), or terminate if no caller
  start statement:   line=34 column=1
  end statement:     line=34 column=21
  source code:       def acquire(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { d: ?d, v: [ 2, "left" ] }
  call trace:        put_left_test(2) --> put_left(?d, [2, "left"])
  stack:             [{:}, [], 25010, { "self": 2 }, None]

Step 198:
  program counter:   1271
  hvm code:          Pop
  explanation:       pop and discard value ()
  module:            deque
  start statement:   line=13 column=5
  end statement:     line=13 column=21
  source code:       acquire(?d->lock)
                     ^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 25010, { "self": 2 }]

Step 199:
  program counter:   1272
  hvm code:          Push {:}
  explanation:       push constant {:}
  start statement:   line=14 column=5
  end statement:     line=14 column=61
  source code:       let node = malloc({ .value: v, .prev: None, .next: None}):
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 25010, { "self": 2 }, {:}]

Step 200:
  program counter:   1273
  hvm code:          Push "value"
  explanation:       push constant "value"
  source code:       let node = malloc({ .value: v, .prev: None, .next: None}):
                                         ^^^^^^
  stack:             [{:}, [], 25010, { "self": 2 }, {:}, "value"]

Step 201:
  program counter:   1274
  hvm code:          LoadVar v
  explanation:       push value ([2, "left"]) of variable "v"
  source code:       let node = malloc({ .value: v, .prev: None, .next: None}):
                                                 ^
  stack:             [{:}, [], 25010, { "self": 2 }, {:}, "value", [ 2, "left" ]]

Step 202:
  program counter:   1275
  hvm code:          DelVar v
  explanation:       delete method variable v
  start expression:  line=14 column=33
  end expression:    line=14 column=33
  method variables:  { d: ?d }

Step 203:
  program counter:   1276
  hvm code:          3-ary DictAdd
  explanation:       pop 3 values ([2, "left"], "value", {:}); add key/value pair to dictionary; push result ({ "value": [2, "left"] })
  source code:       let node = malloc({ .value: v, .prev: None, .next: None}):
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 25010, { "self": 2 }, { "value": [ 2, "left" ] }]

Step 204:
  program counter:   1277
  hvm code:          Push "prev"
  explanation:       push constant "prev"
  source code:       let node = malloc({ .value: v, .prev: None, .next: None}):
                                                    ^^^^^
  stack:             [{:}, [], 25010, { "self": 2 }, { "value": [ 2, "left" ] }, "prev"]

Step 205:
  program counter:   1278
  hvm code:          Push None
  explanation:       push constant None
  source code:       let node = malloc({ .value: v, .prev: None, .next: None}):
                                                           ^^^^
  stack:             [{:}, [], 25010, { "self": 2 }, { "value": [ 2, "left" ] }, "prev", None]

Step 206:
  program counter:   1279
  hvm code:          3-ary DictAdd
  explanation:       pop 3 values (None, "prev", { "value": [2, "left"] }); add key/value pair to dictionary; push result ({ "prev": None, "value": [2, "left"] })
  source code:       let node = malloc({ .value: v, .prev: None, .next: None}):
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 25010, { "self": 2 }, { "prev": None, "value": [ 2, "left" ] }]

Step 207:
  program counter:   1280
  hvm code:          Push "next"
  explanation:       push constant "next"
  source code:       let node = malloc({ .value: v, .prev: None, .next: None}):
                                                                 ^^^^^
  stack:             [{:}, [], 25010, { "self": 2 }, { "prev": None, "value": [ 2, "left" ] }, "next"]

Step 208:
  program counter:   1281
  hvm code:          Push None
  explanation:       push constant None
  source code:       let node = malloc({ .value: v, .prev: None, .next: None}):
                                                                        ^^^^
  stack:             [{:}, [], 25010, { "self": 2 }, { "prev": None, "value": [ 2, "left" ] }, "next", None]

Step 209:
  program counter:   1282
  hvm code:          3-ary DictAdd
  explanation:       pop 3 values (None, "next", { "prev": None, "value": [2, "left"] }); add key/value pair to dictionary; push result ({ "next": None, "prev": None, "value": [2, "left"] })
  source code:       let node = malloc({ .value: v, .prev: None, .next: None}):
                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 25010, { "self": 2 }, { "next": None, "prev": None, "value": [ 2, "left" ] }]

Step 210:
  program counter:   1283
  hvm code:          Apply PC(1210)
  explanation:       pop an argument ({ "next": None, "prev": None, "value": [2, "left"] }) and call method (1210: "malloc")
  source code:       let node = malloc({ .value: v, .prev: None, .next: None}):
                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  call trace:        put_left_test(2) --> put_left(?d, [2, "left"]) --> malloc({ "next": None, "prev": None, "value": [2, "left"] })
  stack:             [{:}, [], 25010, { "self": 2 }, [], 20530, { "next": None, "prev": None, "value": [ 2, "left" ] }]

Step 211:
  program counter:   1210
  hvm code:          Frame malloc(v)
  explanation:       pop argument ({ "next": None, "prev": None, "value": [2, "left"] }), assign to v, and run method "malloc"
  module:            alloc
  start statement:   line=6 column=1
  end statement:     line=6 column=27
  source code:       def malloc(v) returns copy:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { v: { "next": None, "prev": None, "value": [ 2, "left" ] } }
  stack:             [{:}, [], 25010, { "self": 2 }, [], 20530, { "d": ?d }]

Step 212:
  program counter:   1211
  hvm code:          AtomicInc(eager)
  explanation:       increment atomic counter from 0 to 1: becomes atomic
  start statement:   line=7 column=5
  end statement:     line=7 column=15
  source code:       atomically:
                     ^^^^^^^^^^^
  call trace:        put_left_test(2) --> put_left(?d, [2, "left"]) --> malloc({ "next": None, "prev": None, "value": [2, "left"] })

Step 213:
  program counter:   1212
  hvm code:          Push ?alloc$pool
  explanation:       push constant ?alloc$pool
  start statement:   line=8 column=9
  end statement:     line=8 column=22
  source code:       pool[next] = v
                     ^^^^
  stack:             [{:}, [], 25010, { "self": 2 }, [], 20530, { "d": ?d }, ?alloc$pool]

Step 214:
  program counter:   1213
  hvm code:          Load alloc$next
  explanation:       push value (0) of variable alloc$next
  source code:       pool[next] = v
                          ^^^^
  stack:             [{:}, [], 25010, { "self": 2 }, [], 20530, { "d": ?d }, ?alloc$pool, 0]

Step 215:
  program counter:   1214
  hvm code:          2-ary AddArg
  explanation:       pop 2 values (0, ?alloc$pool); push result (?alloc$pool[0])
  source code:       pool[next] = v
                     ^^^^^^^^^^
  stack:             [{:}, [], 25010, { "self": 2 }, [], 20530, { "d": ?d }, ?alloc$pool[0]]

Step 216:
  program counter:   1215
  hvm code:          LoadVar v
  explanation:       push value ({ "next": None, "prev": None, "value": [2, "left"] }) of variable "v"
  source code:       pool[next] = v
                                  ^
  stack:             [{:}, [], 25010, { "self": 2 }, [], 20530, { "d": ?d }, ?alloc$pool[0], { "next": None, "prev": None, "value": [ 2, "left" ] }]

Step 217:
  program counter:   1216
  hvm code:          DelVar v
  explanation:       delete method variable v
  start expression:  line=8 column=22
  end expression:    line=8 column=22
  method variables:  { }

Step 218:
  program counter:   1217
  hvm code:          Store
  explanation:       pop value ({ "next": None, "prev": None, "value": [2, "left"] }) and address (?alloc$pool[0]) and store
  source code:       pool[next] = v
                     ^^^^^^^^^^^^
  shared variables:  { alloc$next: 0, alloc$pool: [ { "next": None, "prev": None, "value": [ 2, "left" ] } ], d: { "head": None, "lock": True, "tail": None } }
  stack:             [{:}, [], 25010, { "self": 2 }, [], 20530, { "d": ?d }]

Step 219:
  program counter:   1218
  hvm code:          Push ?alloc$pool
  explanation:       push constant ?alloc$pool
  start statement:   line=9 column=9
  end statement:     line=9 column=26
  source code:       copy = ?pool[next]
                             ^^^^
  stack:             [{:}, [], 25010, { "self": 2 }, [], 20530, { "d": ?d }, ?alloc$pool]

Step 220:
  program counter:   1219
  hvm code:          Load alloc$next
  explanation:       push value (0) of variable alloc$next
  source code:       copy = ?pool[next]
                                  ^^^^
  stack:             [{:}, [], 25010, { "self": 2 }, [], 20530, { "d": ?d }, ?alloc$pool, 0]

Step 221:
  program counter:   1220
  hvm code:          2-ary AddArg
  explanation:       pop 2 values (0, ?alloc$pool); push result (?alloc$pool[0])
  source code:       copy = ?pool[next]
                             ^^^^^^^^^^
  stack:             [{:}, [], 25010, { "self": 2 }, [], 20530, { "d": ?d }, ?alloc$pool[0]]

Step 222:
  program counter:   1221
  hvm code:          StoreVar copy
  explanation:       pop value (?alloc$pool[0]) and store locally in variable \"copy\"
  source code:       copy = ?pool[next]
                     ^^^^^^
  method variables:  { copy: ?alloc$pool[0] }
  stack:             [{:}, [], 25010, { "self": 2 }, [], 20530, { "d": ?d }]

Step 223:
  program counter:   1222
  hvm code:          Load alloc$next
  explanation:       push value (0) of variable alloc$next
  start statement:   line=10 column=9
  end statement:     line=10 column=17
  source code:       next += 1
                     ^^^^^^^^^
  stack:             [{:}, [], 25010, { "self": 2 }, [], 20530, { "d": ?d }, 0]

Step 224:
  program counter:   1223
  hvm code:          Push 1
  explanation:       push constant 1
  source code:       next += 1
                             ^
  stack:             [{:}, [], 25010, { "self": 2 }, [], 20530, { "d": ?d }, 0, 1]

Step 225:
  program counter:   1224
  hvm code:          2-ary +
  explanation:       pop 2 values (1, 0); add the integers; push result (1)
  source code:       next += 1
                     ^^^^^^^^^
  stack:             [{:}, [], 25010, { "self": 2 }, [], 20530, { "d": ?d }, 1]

Step 226:
  program counter:   1225
  hvm code:          Store alloc$next
  explanation:       pop value (1) and store into variable alloc$next
  source code:       next += 1
                     ^^^^^^^
  shared variables:  { alloc$next: 1, alloc$pool: [ { "next": None, "prev": None, "value": [ 2, "left" ] } ], d: { "head": None, "lock": True, "tail": None } }
  stack:             [{:}, [], 25010, { "self": 2 }, [], 20530, { "d": ?d }]

Step 227:
  program counter:   1226
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 1 to 0: no longer atomic
  start statement:   line=7 column=5
  end statement:     line=7 column=15
  source code:       atomically:
                     ^^^^^^^^^^^

Step 228:
  program counter:   1227
  hvm code:          ReturnOp(copy)
  explanation:       pop caller's method variables and pc and push result (), or terminate if no caller
  start statement:   line=6 column=1
  end statement:     line=6 column=27
  source code:       def malloc(v) returns copy:
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { d: ?d }
  call trace:        put_left_test(2) --> put_left(?d, [2, "left"])
  stack:             [{:}, [], 25010, { "self": 2 }, ?alloc$pool[0]]

Step 229:
  program counter:   1284
  hvm code:          StoreVar node
  explanation:       pop value (?alloc$pool[0]) and store locally in variable \"node\"
  module:            deque
  start statement:   line=14 column=5
  end statement:     line=14 column=61
  source code:       let node = malloc({ .value: v, .prev: None, .next: None}):
                     ^^^^^^^^^^
  method variables:  { d: ?d, node: ?alloc$pool[0] }
  stack:             [{:}, [], 25010, { "self": 2 }]

Step 230:
  program counter:   1285
  hvm code:          LoadVar d
  explanation:       push value (?d) of variable "d"
  start statement:   line=15 column=9
  end statement:     line=15 column=27
  source code:       if d->head == None:
                        ^
  stack:             [{:}, [], 25010, { "self": 2 }, ?d]

Step 231:
  program counter:   1286
  hvm code:          Push "head"
  explanation:       push constant "head"
  source code:       if d->head == None:
                           ^^^^
  stack:             [{:}, [], 25010, { "self": 2 }, ?d, "head"]

Step 232:
  program counter:   1287
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("head", ?d); push result (?d["head"])
  source code:       if d->head == None:
                        ^^^^^^^
  stack:             [{:}, [], 25010, { "self": 2 }, ?d["head"]]

Step 233:
  program counter:   1288
  hvm code:          Load
  explanation:       pop address (?d["head"]) and push value (None)
  start expression:  line=15 column=12
  end expression:    line=15 column=18
  call trace:        put_left_test(2) --> put_left(?d, [2, "left"])
  stack:             [{:}, [], 25010, { "self": 2 }, None]

Step 234:
  program counter:   1289
  hvm code:          Push None
  explanation:       push constant None
  source code:       if d->head == None:
                                   ^^^^
  stack:             [{:}, [], 25010, { "self": 2 }, None, None]

Step 235:
  program counter:   1290
  hvm code:          2-ary ==
  explanation:       pop 2 values (None, None); check if both values are the same; push result (True)
  source code:       if d->head == None:
                        ^^^^^^^^^^^^^^^
  stack:             [{:}, [], 25010, { "self": 2 }, True]

Step 236:
  program counter:   1291
  hvm code:          JumpCond False 1306
  explanation:       pop value (True), compare to False, and jump to 1306 if the same
  source code:       if d->head == None:
                     ^^
  stack:             [{:}, [], 25010, { "self": 2 }]

Step 237:
  program counter:   1292
  hvm code:          LoadVar d
  explanation:       push value (?d) of variable "d"
  start statement:   line=16 column=13
  end statement:     line=16 column=36
  source code:       d->head = d->tail = node
                     ^
  stack:             [{:}, [], 25010, { "self": 2 }, ?d]

Step 238:
  program counter:   1293
  hvm code:          Push "head"
  explanation:       push constant "head"
  source code:       d->head = d->tail = node
                        ^^^^
  stack:             [{:}, [], 25010, { "self": 2 }, ?d, "head"]

Step 239:
  program counter:   1294
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("head", ?d); push result (?d["head"])
  source code:       d->head = d->tail = node
                     ^^^^^^^
  stack:             [{:}, [], 25010, { "self": 2 }, ?d["head"]]

Step 240:
  program counter:   1295
  hvm code:          LoadVar d
  explanation:       push value (?d) of variable "d"
  source code:       d->head = d->tail = node
                               ^
  stack:             [{:}, [], 25010, { "self": 2 }, ?d["head"], ?d]

Step 241:
  program counter:   1296
  hvm code:          Push "tail"
  explanation:       push constant "tail"
  source code:       d->head = d->tail = node
                                  ^^^^
  stack:             [{:}, [], 25010, { "self": 2 }, ?d["head"], ?d, "tail"]

Step 242:
  program counter:   1297
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("tail", ?d); push result (?d["tail"])
  source code:       d->head = d->tail = node
                               ^^^^^^^
  stack:             [{:}, [], 25010, { "self": 2 }, ?d["head"], ?d["tail"]]

Step 243:
  program counter:   1298
  hvm code:          LoadVar node
  explanation:       push value (?alloc$pool[0]) of variable "node"
  source code:       d->head = d->tail = node
                                         ^^^^
  stack:             [{:}, [], 25010, { "self": 2 }, ?d["head"], ?d["tail"], ?alloc$pool[0]]

Step 244:
  program counter:   1299
  hvm code:          DelVar node
  explanation:       delete method variable node
  start expression:  line=16 column=33
  end expression:    line=16 column=36
  method variables:  { d: ?d }

Step 245:
  program counter:   1300
  hvm code:          Dup
  explanation:       push a copy of the top value on the stack
  source code:       d->head = d->tail = node
                             ^
  stack:             [{:}, [], 25010, { "self": 2 }, ?d["head"], ?d["tail"], ?alloc$pool[0], ?alloc$pool[0]]

Step 246:
  program counter:   1301
  hvm code:          Move 3
  explanation:       move stack element to top
  source code:       d->head = d->tail = node
                               ^^^^^^^
  stack:             [{:}, [], 25010, { "self": 2 }, ?d["head"], ?alloc$pool[0], ?alloc$pool[0], ?d["tail"]]

Step 247:
  program counter:   1302
  hvm code:          Move 2
  explanation:       move stack element to top
  start expression:  line=16 column=23
  end expression:    line=16 column=29
  stack:             [{:}, [], 25010, { "self": 2 }, ?d["head"], ?alloc$pool[0], ?d["tail"], ?alloc$pool[0]]

Step 248:
  program counter:   1303
  hvm code:          Store
  explanation:       pop value (?alloc$pool[0]) and address (?d["tail"]) and store
  source code:       d->head = d->tail = node
                               ^^^^^^^^^
  shared variables:  { alloc$next: 1, alloc$pool: [ { "next": None, "prev": None, "value": [ 2, "left" ] } ], d: { "head": None, "lock": True, "tail": ?alloc$pool[0] } }
  call trace:        put_left_test(2) --> put_left(?d, [2, "left"])
  stack:             [{:}, [], 25010, { "self": 2 }, ?d["head"], ?alloc$pool[0]]

Step 249:
  program counter:   1304
  hvm code:          Store
  explanation:       pop value (?alloc$pool[0]) and address (?d["head"]) and store
  source code:       d->head = d->tail = node
                     ^^^^^^^^^
  shared variables:  { alloc$next: 1, alloc$pool: [ { "next": None, "prev": None, "value": [ 2, "left" ] } ], d: { "head": ?alloc$pool[0], "lock": True, "tail": ?alloc$pool[0] } }
  call trace:        put_left_test(2) --> put_left(?d, [2, "left"])
  stack:             [{:}, [], 25010, { "self": 2 }]

Step 250:
  program counter:   1305
  hvm code:          Jump 1328
  explanation:       set program counter to 1328
  start statement:   line=15 column=9
  end statement:     line=15 column=27
  source code:       if d->head == None:
                     ^^^^^^^^^^^^^^^^^^^

Step 251:
  program counter:   1328
  hvm code:          LoadVar d
  explanation:       push value (?d) of variable "d"
  start statement:   line=21 column=5
  end statement:     line=21 column=21
  source code:       release(?d->lock)
                              ^
  stack:             [{:}, [], 25010, { "self": 2 }, ?d]

Step 252:
  program counter:   1329
  hvm code:          DelVar d
  explanation:       delete method variable d
  start expression:  line=21 column=14
  end expression:    line=21 column=14
  method variables:  { }

Step 253:
  program counter:   1330
  hvm code:          Push "lock"
  explanation:       push constant "lock"
  source code:       release(?d->lock)
                                 ^^^^
  stack:             [{:}, [], 25010, { "self": 2 }, ?d, "lock"]

Step 254:
  program counter:   1331
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("lock", ?d); push result (?d["lock"])
  source code:       release(?d->lock)
                              ^^^^^^^
  stack:             [{:}, [], 25010, { "self": 2 }, ?d["lock"]]

Step 255:
  program counter:   1332
  hvm code:          Apply PC(973)
  explanation:       pop an argument (?d["lock"]) and call method (973: "release")
  source code:       release(?d->lock)
                     ^^^^^^^^^^^^^^^^^
  call trace:        put_left_test(2) --> put_left(?d, [2, "left"]) --> release(?d["lock"])
  stack:             [{:}, [], 25010, { "self": 2 }, [], 21314, ?d["lock"]]

Step 256:
  program counter:   973
  hvm code:          Frame release(binsema)
  explanation:       pop argument (?d["lock"]), assign to binsema, and run method "release"
  module:            synch
  start statement:   line=38 column=1
  end statement:     line=38 column=21
  source code:       def release(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { binsema: ?d["lock"] }
  stack:             [{:}, [], 25010, { "self": 2 }, [], 21314, {:}]

Step 257:
  program counter:   974
  hvm code:          AtomicInc(eager)
  explanation:       increment atomic counter from 0 to 1: becomes atomic
  start statement:   line=39 column=5
  end statement:     line=39 column=15
  source code:       atomically:
                     ^^^^^^^^^^^
  call trace:        put_left_test(2) --> put_left(?d, [2, "left"]) --> release(?d["lock"])

Step 258:
  program counter:   975
  hvm code:          AtomicInc(lazy)
  explanation:       increment atomic counter from 1 to 2: remains atomic
  start statement:   line=40 column=9
  end statement:     line=40 column=23
  source code:       assert !binsema
                     ^^^^^^^^^^^^^^^

Step 259:
  program counter:   976
  hvm code:          ReadonlyInc
  explanation:       increment readonly counter from 0 to 1: becomes readonly
  start expression:  line=40 column=9
  end expression:    line=40 column=23

Step 260:
  program counter:   977
  hvm code:          LoadVar binsema
  explanation:       push value (?d["lock"]) of variable "binsema"
  source code:       assert !binsema
                             ^^^^^^^
  stack:             [{:}, [], 25010, { "self": 2 }, [], 21314, {:}, ?d["lock"]]

Step 261:
  program counter:   978
  hvm code:          Load
  explanation:       pop address (?d["lock"]) and push value (True)
  source code:       assert !binsema
                            ^^^^^^^^
  stack:             [{:}, [], 25010, { "self": 2 }, [], 21314, {:}, True]

Step 262:
  program counter:   979
  hvm code:          Assert
  explanation:       pop a value (True); do not raise exception
  source code:       assert !binsema
                     ^^^^^^
  stack:             [{:}, [], 25010, { "self": 2 }, [], 21314, {:}]

Step 263:
  program counter:   980
  hvm code:          ReadonlyDec
  explanation:       decrement readonly counter from 1 to 0: no longer readonly
  source code:       assert !binsema
                     ^^^^^^^^^^^^^^^

Step 264:
  program counter:   981
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 2 to 1: remains atomic
  start expression:  line=40 column=9
  end expression:    line=40 column=23

Step 265:
  program counter:   982
  hvm code:          LoadVar binsema
  explanation:       push value (?d["lock"]) of variable "binsema"
  start statement:   line=41 column=9
  end statement:     line=41 column=24
  source code:       !binsema = False
                      ^^^^^^^
  stack:             [{:}, [], 25010, { "self": 2 }, [], 21314, {:}, ?d["lock"]]

Step 266:
  program counter:   983
  hvm code:          DelVar binsema
  explanation:       delete method variable binsema
  start expression:  line=41 column=10
  end expression:    line=41 column=16
  method variables:  { }

Step 267:
  program counter:   984
  hvm code:          Push False
  explanation:       push constant False
  source code:       !binsema = False
                                ^^^^^
  stack:             [{:}, [], 25010, { "self": 2 }, [], 21314, {:}, ?d["lock"], False]

Step 268:
  program counter:   985
  hvm code:          Store
  explanation:       pop value (False) and address (?d["lock"]) and store
  source code:       !binsema = False
                     ^^^^^^^^^^
  shared variables:  { alloc$next: 1, alloc$pool: [ { "next": None, "prev": None, "value": [ 2, "left" ] } ], d: { "head": ?alloc$pool[0], "lock": False, "tail": ?alloc$pool[0] } }
  stack:             [{:}, [], 25010, { "self": 2 }, [], 21314, {:}]

Step 269:
  program counter:   986
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 1 to 0: no longer atomic
  start statement:   line=39 column=5
  end statement:     line=39 column=15
  source code:       atomically:
                     ^^^^^^^^^^^

Step 270:
  program counter:   987
  hvm code:          ReturnOp(result. None)
  explanation:       pop caller's method variables and pc and push result (), or terminate if no caller
  start statement:   line=38 column=1
  end statement:     line=38 column=21
  source code:       def release(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  call trace:        put_left_test(2) --> put_left(?d, [2, "left"])
  stack:             [{:}, [], 25010, { "self": 2 }, None]

Step 271:
  program counter:   1333
  hvm code:          Pop
  explanation:       pop and discard value ()
  module:            deque
  start statement:   line=21 column=5
  end statement:     line=21 column=21
  source code:       release(?d->lock)
                     ^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 25010, { "self": 2 }]

Step 272:
  program counter:   1334
  hvm code:          ReturnOp(result. None)
  explanation:       pop caller's method variables and pc and push result (), or terminate if no caller
  start statement:   line=7 column=1
  end statement:     line=7 column=19
  source code:       def put_left(d, v):
                     ^^^^^^^^^^^^^^^^^^^
  method variables:  { self: 2 }
  call trace:        put_left_test(2)
  stack:             [{:}, None]

Step 273:
  program counter:   1564
  hvm code:          Pop
  explanation:       pop and discard value ()
  module:            __main__
  start statement:   line=35 column=5
  end statement:     line=35 column=37
  source code:       deque.put_left(?d, (self,"left"))
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}]

Step 274:
  program counter:   1565
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  start statement:   line=36 column=5
  end statement:     line=36 column=41
  source code:       print("done put_left", (self,"left"))
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, []]

Step 275:
  program counter:   1566
  hvm code:          Push "done put_left"
  explanation:       push constant "done put_left"
  source code:       print("done put_left", (self,"left"))
                           ^^^^^^^^^^^^^^^
  stack:             [{:}, [], "done put_left"]

Step 276:
  program counter:   1567
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values ("done put_left", []); insert first value into the second; push result (["done put_left"])
  source code:       print("done put_left", (self,"left"))
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [ "done put_left" ]]

Step 277:
  program counter:   1568
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  source code:       print("done put_left", (self,"left"))
                                             ^^^^^^^^^^^
  stack:             [{:}, [ "done put_left" ], []]

Step 278:
  program counter:   1569
  hvm code:          LoadVar self
  explanation:       push value (2) of variable "self"
  source code:       print("done put_left", (self,"left"))
                                             ^^^^
  stack:             [{:}, [ "done put_left" ], [], 2]

Step 279:
  program counter:   1570
  hvm code:          DelVar self
  explanation:       delete method variable self
  start expression:  line=36 column=29
  end expression:    line=36 column=32
  method variables:  { }

Step 280:
  program counter:   1571
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (2, []); insert first value into the second; push result ([2])
  source code:       print("done put_left", (self,"left"))
                                             ^^^^^^^^^^^
  stack:             [{:}, [ "done put_left" ], [ 2 ]]

Step 281:
  program counter:   1572
  hvm code:          Push "left"
  explanation:       push constant "left"
  source code:       print("done put_left", (self,"left"))
                                                  ^^^^^^
  stack:             [{:}, [ "done put_left" ], [ 2 ], "left"]

Step 282:
  program counter:   1573
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values ("left", [2]); insert first value into the second; push result ([2, "left"])
  source code:       print("done put_left", (self,"left"))
                                             ^^^^^^^^^^^
  stack:             [{:}, [ "done put_left" ], [ 2, "left" ]]

Step 283:
  program counter:   1574
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values ([2, "left"], ["done put_left"]); insert first value into the second; push result (["done put_left", [2, "left"]])
  source code:       print("done put_left", (self,"left"))
                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [ "done put_left", [ 2, "left" ] ]]

================================================
Running thread T5: get_left_test(1)
mode:  runnable
stack: ['1']
other threads:
  T0: pc=1718 terminated atomic __init__()
  T1: pc=1541 runnable put_left_test(1)
    about to run method put_left_test with argument 1
  T2: pc=1575 runnable put_left_test(2)
    about to print [ "done put_left", [ 2, "left" ] ]
  T3: pc=1578 runnable put_right_test(1)
    about to run method put_right_test with argument 1
  T4: pc=1578 runnable put_right_test(2)
    about to run method put_right_test with argument 2
  T6: pc=1639 runnable get_right_test(1)
    about to run method get_right_test with argument 1
shared variables:
  alloc$next: 1
  alloc$pool: [ { "next": None, "prev": None, "value": [ 2, "left" ] } ]
  d: { "head": ?alloc$pool[0], "lock": False, "tail": ?alloc$pool[0] }
state id: 2872
================================================

Step 284:
  program counter:   1615
  hvm code:          Frame get_left_test(self)
  explanation:       pop argument (1), assign to self, and run method "get_left_test"
  start statement:   line=43 column=1
  end statement:     line=43 column=24
  source code:       def get_left_test(self):
                     ^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { self: 1 }
  call trace:        get_left_test(1)
  stack:             [{:}]

Step 285:
  program counter:   1616
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  start statement:   line=44 column=5
  end statement:     line=44 column=32
  source code:       print("call get_left", self)
                           ^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, []]

Step 286:
  program counter:   1617
  hvm code:          Push "call get_left"
  explanation:       push constant "call get_left"
  source code:       print("call get_left", self)
                           ^^^^^^^^^^^^^^^
  stack:             [{:}, [], "call get_left"]

Step 287:
  program counter:   1618
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values ("call get_left", []); insert first value into the second; push result (["call get_left"])
  source code:       print("call get_left", self)
                           ^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [ "call get_left" ]]

Step 288:
  program counter:   1619
  hvm code:          LoadVar self
  explanation:       push value (1) of variable "self"
  source code:       print("call get_left", self)
                                            ^^^^
  stack:             [{:}, [ "call get_left" ], 1]

Step 289:
  program counter:   1620
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (1, ["call get_left"]); insert first value into the second; push result (["call get_left", 1])
  source code:       print("call get_left", self)
                           ^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, [ "call get_left", 1 ]]

Step 290:
  program counter:   1621
  hvm code:          Print
  explanation:       pop value (["call get_left", 1]) and add to print log
  source code:       print("call get_left", self)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  call trace:        get_left_test(1)
  stack:             [{:}]

Step 291:
  program counter:   1622
  hvm code:          Push PC(1406)
  explanation:       push program counter constant 1406 ()
  start statement:   line=45 column=5
  end statement:     line=45 column=30
  source code:       let v = deque.get_left(?d):
                             ^^^^^^^^^^^^^^
  stack:             [{:}, PC(1406)]

Step 292:
  program counter:   1623
  hvm code:          Push ?d
  explanation:       push constant ?d
  source code:       let v = deque.get_left(?d):
                                             ^
  stack:             [{:}, PC(1406), ?d]

Step 293:
  program counter:   1624
  hvm code:          2-ary Closure
  explanation:       pop 2 values (?d, PC(1406)); push result (?PC(1406)[?d])
  source code:       let v = deque.get_left(?d):
                             ^^^^^^^^^^^^^^^^^^
  stack:             [{:}, ?PC(1406)[?d]]

Step 294:
  program counter:   1625
  hvm code:          Load
  explanation:       pop an argument (?d) and call method (1406: "get_left")
  start expression:  line=45 column=13
  end expression:    line=45 column=30
  call trace:        get_left_test(1) --> get_left(?d)
  stack:             [{:}, [], 26002, ?d]

Step 295:
  program counter:   1406
  hvm code:          Frame get_left(d)
  explanation:       pop argument (?d), assign to d, and run method "get_left"
  module:            deque
  start statement:   line=40 column=1
  end statement:     line=40 column=29
  source code:       def get_left(d) returns next: 
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { d: ?d }
  stack:             [{:}, [], 26002, { "self": 1 }]

Step 296:
  program counter:   1407
  hvm code:          LoadVar d
  explanation:       push value (?d) of variable "d"
  start statement:   line=46 column=5
  end statement:     line=46 column=21
  source code:       acquire(?d->lock)
                              ^
  stack:             [{:}, [], 26002, { "self": 1 }, ?d]

Step 297:
  program counter:   1408
  hvm code:          Push "lock"
  explanation:       push constant "lock"
  source code:       acquire(?d->lock)
                                 ^^^^
  stack:             [{:}, [], 26002, { "self": 1 }, ?d, "lock"]

Step 298:
  program counter:   1409
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("lock", ?d); push result (?d["lock"])
  source code:       acquire(?d->lock)
                              ^^^^^^^
  stack:             [{:}, [], 26002, { "self": 1 }, ?d["lock"]]

Step 299:
  program counter:   1410
  hvm code:          Apply PC(954)
  explanation:       pop an argument (?d["lock"]) and call method (954: "acquire")
  source code:       acquire(?d->lock)
                     ^^^^^^^^^^^^^^^^^
  call trace:        get_left_test(1) --> get_left(?d) --> acquire(?d["lock"])
  stack:             [{:}, [], 26002, { "self": 1 }, [], 22562, ?d["lock"]]

Step 300:
  program counter:   954
  hvm code:          Frame acquire(binsema)
  explanation:       pop argument (?d["lock"]), assign to binsema, and run method "acquire"
  module:            synch
  start statement:   line=34 column=1
  end statement:     line=34 column=21
  source code:       def acquire(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { binsema: ?d["lock"] }
  stack:             [{:}, [], 26002, { "self": 1 }, [], 22562, { "d": ?d }]

Step 301:
  program counter:   955
  hvm code:          AtomicInc(eager)
  explanation:       increment atomic counter from 0 to 1: becomes atomic
  start statement:   line=35 column=16
  end statement:     line=37 column=6
  source code:       atomically when not !binsema:
  call trace:        get_left_test(1) --> get_left(?d) --> acquire(?d["lock"])

Step 302:
  program counter:   956
  hvm code:          ReadonlyInc
  explanation:       increment readonly counter from 0 to 1: becomes readonly
  source code:       atomically when not !binsema:

Step 303:
  program counter:   957
  hvm code:          LoadVar binsema
  explanation:       push value (?d["lock"]) of variable "binsema"
  start statement:   line=35 column=16
  end statement:     line=35 column=32
  source code:       atomically when not !binsema:
                                          ^^^^^^^
  stack:             [{:}, [], 26002, { "self": 1 }, [], 22562, { "d": ?d }, ?d["lock"]]

Step 304:
  program counter:   958
  hvm code:          Load
  explanation:       pop address (?d["lock"]) and push value (False)
  source code:       atomically when not !binsema:
                                         ^^^^^^^^
  stack:             [{:}, [], 26002, { "self": 1 }, [], 22562, { "d": ?d }, False]

Step 305:
  program counter:   959
  hvm code:          1-ary not
  explanation:       pop a value (False); logical not; push result (True)
  source code:       atomically when not !binsema:
                                     ^^^^^^^^^^^^
  stack:             [{:}, [], 26002, { "self": 1 }, [], 22562, { "d": ?d }, True]

Step 306:
  program counter:   960
  hvm code:          JumpCond False 962
  explanation:       pop value (True), compare to False, and jump to 962 if the same
  source code:       atomically when not !binsema:
                                ^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 26002, { "self": 1 }, [], 22562, { "d": ?d }]

Step 307:
  program counter:   961
  hvm code:          Jump 965
  explanation:       set program counter to 965
  source code:       atomically when not !binsema:
                                                ^

Step 308:
  program counter:   965
  hvm code:          ReadonlyDec
  explanation:       decrement readonly counter from 1 to 0: no longer readonly
  source code:       atomically when not !binsema:
                                ^^^^^^^^^^^^^^^^^

Step 309:
  program counter:   966
  hvm code:          LoadVar binsema
  explanation:       push value (?d["lock"]) of variable "binsema"
  start statement:   line=36 column=9
  end statement:     line=36 column=23
  source code:       !binsema = True
                      ^^^^^^^
  stack:             [{:}, [], 26002, { "self": 1 }, [], 22562, { "d": ?d }, ?d["lock"]]

Step 310:
  program counter:   967
  hvm code:          DelVar binsema
  explanation:       delete method variable binsema
  start expression:  line=36 column=10
  end expression:    line=36 column=16
  method variables:  { }

Step 311:
  program counter:   968
  hvm code:          Push True
  explanation:       push constant True
  source code:       !binsema = True
                                ^^^^
  stack:             [{:}, [], 26002, { "self": 1 }, [], 22562, { "d": ?d }, ?d["lock"], True]

Step 312:
  program counter:   969
  hvm code:          Store
  explanation:       pop value (True) and address (?d["lock"]) and store
  source code:       !binsema = True
                     ^^^^^^^^^^
  shared variables:  { alloc$next: 1, alloc$pool: [ { "next": None, "prev": None, "value": [ 2, "left" ] } ], d: { "head": ?alloc$pool[0], "lock": True, "tail": ?alloc$pool[0] } }
  stack:             [{:}, [], 26002, { "self": 1 }, [], 22562, { "d": ?d }]

Step 313:
  program counter:   970
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 1 to 0: no longer atomic
  start statement:   line=35 column=16
  end statement:     line=35 column=32
  source code:       atomically when not !binsema:
                                ^^^^^^^^^^^^^^^^^

Step 314:
  program counter:   971
  hvm code:          ReturnOp(result. None)
  explanation:       pop caller's method variables and pc and push result (), or terminate if no caller
  start statement:   line=34 column=1
  end statement:     line=34 column=21
  source code:       def acquire(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { d: ?d }
  call trace:        get_left_test(1) --> get_left(?d)
  stack:             [{:}, [], 26002, { "self": 1 }, None]

Step 315:
  program counter:   1411
  hvm code:          Pop
  explanation:       pop and discard value ()
  module:            deque
  start statement:   line=46 column=5
  end statement:     line=46 column=21
  source code:       acquire(?d->lock)
                     ^^^^^^^^^^^^^^^^^
  stack:             [{:}, [], 26002, { "self": 1 }]

Step 316:
  program counter:   1412
  hvm code:          LoadVar d
  explanation:       push value (?d) of variable "d"
  start statement:   line=47 column=5
  end statement:     line=47 column=22
  source code:       let node = d->head:
                                ^
  stack:             [{:}, [], 26002, { "self": 1 }, ?d]

Step 317:
  program counter:   1413
  hvm code:          Push "head"
  explanation:       push constant "head"
  source code:       let node = d->head:
                                   ^^^^
  stack:             [{:}, [], 26002, { "self": 1 }, ?d, "head"]

Step 318:
  program counter:   1414
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("head", ?d); push result (?d["head"])
  source code:       let node = d->head:
                                ^^^^^^^
  stack:             [{:}, [], 26002, { "self": 1 }, ?d["head"]]

Step 319:
  program counter:   1415
  hvm code:          Load
  explanation:       pop address (?d["head"]) and push value (?alloc$pool[0])
  start expression:  line=47 column=16
  end expression:    line=47 column=22
  call trace:        get_left_test(1) --> get_left(?d)
  stack:             [{:}, [], 26002, { "self": 1 }, ?alloc$pool[0]]

Step 320:
  program counter:   1416
  hvm code:          StoreVar node
  explanation:       pop value (?alloc$pool[0]) and store locally in variable \"node\"
  source code:       let node = d->head:
                     ^^^^^^^^^^
  method variables:  { d: ?d, node: ?alloc$pool[0] }
  stack:             [{:}, [], 26002, { "self": 1 }]

Step 321:
  program counter:   1417
  hvm code:          LoadVar node
  explanation:       push value (?alloc$pool[0]) of variable "node"
  start statement:   line=48 column=9
  end statement:     line=48 column=24
  source code:       if node == None:
                        ^^^^
  stack:             [{:}, [], 26002, { "self": 1 }, ?alloc$pool[0]]

Step 322:
  program counter:   1418
  hvm code:          Push None
  explanation:       push constant None
  source code:       if node == None:
                                ^^^^
  stack:             [{:}, [], 26002, { "self": 1 }, ?alloc$pool[0], None]

Step 323:
  program counter:   1419
  hvm code:          2-ary ==
  explanation:       pop 2 values (None, ?alloc$pool[0]); check if both values are the same; push result (False)
  source code:       if node == None:
                        ^^^^^^^^^^^^
  stack:             [{:}, [], 26002, { "self": 1 }, False]

Step 324:
  program counter:   1420
  hvm code:          JumpCond False 1425
  explanation:       pop value (False), compare to False, and jump to 1425 if the same
  source code:       if node == None:
                     ^^
  stack:             [{:}, [], 26002, { "self": 1 }]

Step 325:
  program counter:   1425
  hvm code:          LoadVar node
  explanation:       push value (?alloc$pool[0]) of variable "node"
  start statement:   line=51 column=13
  end statement:     line=51 column=30
  source code:       next = node->value
                            ^^^^
  stack:             [{:}, [], 26002, { "self": 1 }, ?alloc$pool[0]]

Step 326:
  program counter:   1426
  hvm code:          Push "value"
  explanation:       push constant "value"
  source code:       next = node->value
                                  ^^^^^
  stack:             [{:}, [], 26002, { "self": 1 }, ?alloc$pool[0], "value"]

Step 327:
  program counter:   1427
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("value", ?alloc$pool[0]); push result (?alloc$pool[0]["value"])
  source code:       next = node->value
                            ^^^^^^^^^^^
  stack:             [{:}, [], 26002, { "self": 1 }, ?alloc$pool[0]["value"]]

Step 328:
  program counter:   1428
  hvm code:          Load
  explanation:       pop address (?alloc$pool[0]["value"]) and push value ([2, "left"])
  start expression:  line=51 column=20
  end expression:    line=51 column=30
  call trace:        get_left_test(1) --> get_left(?d)
  stack:             [{:}, [], 26002, { "self": 1 }, [ 2, "left" ]]

Step 329:
  program counter:   1429
  hvm code:          StoreVar next
  explanation:       pop value ([2, "left"]) and store locally in variable \"next\"
  source code:       next = node->value
                     ^^^^^^
  method variables:  { d: ?d, next: [ 2, "left" ], node: ?alloc$pool[0] }
  stack:             [{:}, [], 26002, { "self": 1 }]

Step 330:
  program counter:   1430
  hvm code:          LoadVar d
  explanation:       push value (?d) of variable "d"
  start statement:   line=52 column=13
  end statement:     line=52 column=32
  source code:       d->head = node->next
                     ^
  stack:             [{:}, [], 26002, { "self": 1 }, ?d]

Step 331:
  program counter:   1431
  hvm code:          Push "head"
  explanation:       push constant "head"
  source code:       d->head = node->next
                        ^^^^
  stack:             [{:}, [], 26002, { "self": 1 }, ?d, "head"]

Step 332:
  program counter:   1432
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("head", ?d); push result (?d["head"])
  source code:       d->head = node->next
                     ^^^^^^^
  stack:             [{:}, [], 26002, { "self": 1 }, ?d["head"]]

Step 333:
  program counter:   1433
  hvm code:          LoadVar node
  explanation:       push value (?alloc$pool[0]) of variable "node"
  source code:       d->head = node->next
                               ^^^^
  stack:             [{:}, [], 26002, { "self": 1 }, ?d["head"], ?alloc$pool[0]]

Step 334:
  program counter:   1434
  hvm code:          Push "next"
  explanation:       push constant "next"
  source code:       d->head = node->next
                                     ^^^^
  stack:             [{:}, [], 26002, { "self": 1 }, ?d["head"], ?alloc$pool[0], "next"]

Step 335:
  program counter:   1435
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("next", ?alloc$pool[0]); push result (?alloc$pool[0]["next"])
  source code:       d->head = node->next
                               ^^^^^^^^^^
  stack:             [{:}, [], 26002, { "self": 1 }, ?d["head"], ?alloc$pool[0]["next"]]

Step 336:
  program counter:   1436
  hvm code:          Load
  explanation:       pop address (?alloc$pool[0]["next"]) and push value (None)
  start expression:  line=52 column=23
  end expression:    line=52 column=32
  call trace:        get_left_test(1) --> get_left(?d)
  stack:             [{:}, [], 26002, { "self": 1 }, ?d["head"], None]

Step 337:
  program counter:   1437
  hvm code:          Store
  explanation:       pop value (None) and address (?d["head"]) and store
  source code:       d->head = node->next
                     ^^^^^^^^^
  shared variables:  { alloc$next: 1, alloc$pool: [ { "next": None, "prev": None, "value": [ 2, "left" ] } ], d: { "head": None, "lock": True, "tail": ?alloc$pool[0] } }
  call trace:        get_left_test(1) --> get_left(?d)
  stack:             [{:}, [], 26002, { "self": 1 }]

Step 338:
  program counter:   1438
  hvm code:          LoadVar d
  explanation:       push value (?d) of variable "d"
  start statement:   line=53 column=13
  end statement:     line=53 column=30
  source code:       d->head->prev=None
                     ^
  stack:             [{:}, [], 26002, { "self": 1 }, ?d]

Step 339:
  program counter:   1439
  hvm code:          Push "head"
  explanation:       push constant "head"
  source code:       d->head->prev=None
                        ^^^^
  stack:             [{:}, [], 26002, { "self": 1 }, ?d, "head"]

Step 340:
  program counter:   1440
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("head", ?d); push result (?d["head"])
  source code:       d->head->prev=None
                     ^^^^^^^
  stack:             [{:}, [], 26002, { "self": 1 }, ?d["head"]]

Step 341:
  program counter:   1441
  hvm code:          Load
  explanation:       pop address (?d["head"]) and push value (None)
  start expression:  line=53 column=13
  end expression:    line=53 column=19
  call trace:        get_left_test(1) --> get_left(?d)
  stack:             [{:}, [], 26002, { "self": 1 }, None]

Step 342:
  program counter:   1442
  hvm code:          Push "prev"
  explanation:       push constant "prev"
  source code:       d->head->prev=None
                              ^^^^
  stack:             [{:}, [], 26002, { "self": 1 }, None, "prev"]

Step 343:
  program counter:   1443
  hvm code:          2-ary AddArg
  explanation:       pop 2 values ("prev", None); push result (?"prev")
  source code:       d->head->prev=None
                     ^^^^^^^^^^^^^
  stack:             [{:}, [], 26002, { "self": 1 }, ?"prev"]

Step 344:
  program counter:   1444
  hvm code:          Push None
  explanation:       push constant None
  source code:       d->head->prev=None
                                   ^^^^
  stack:             [{:}, [], 26002, { "self": 1 }, ?"prev", None]

Step 345:
  program counter:   1445
  hvm code:          Store
  explanation:       pop a value and an address and store the value at the address
  source code:       d->head->prev=None
                     ^^^^^^^^^^^^^^
  call trace:        get_left_test(1) --> get_left(?d)
  new mode:          failed
  stack:             [{:}, [], 26002, { "self": 1 }]
  operation failed:  Store ?"prev": not an address

================================================
Final state
================================================
Threads:
  T0: pc=1718 terminated atomic __init__()
  T1: pc=1541 runnable put_left_test(1)
    about to run method put_left_test with argument 1
  T2: pc=1575 runnable put_left_test(2)
    about to print [ "done put_left", [ 2, "left" ] ]
  T3: pc=1578 runnable put_right_test(1)
    about to run method put_right_test with argument 1
  T4: pc=1578 runnable put_right_test(2)
    about to run method put_right_test with argument 2
  T5: pc=1445 failed get_left_test(1) --> get_left(?d)
  T6: pc=1639 runnable get_right_test(1)
    about to run method get_right_test with argument 1
Variables:
  alloc$next: 1
  alloc$pool: [ { "next": None, "prev": None, "value": [ 2, "left" ] } ]
  d: { "head": None, "lock": True, "tail": ?alloc$pool[0] }
